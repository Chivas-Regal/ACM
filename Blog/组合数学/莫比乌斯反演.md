
- [ğŸ“•å‰ç½®èŠå£« â€”â€” è«æ¯”ä¹Œæ–¯å‡½æ•°](#å‰ç½®èŠå£«--è«æ¯”ä¹Œæ–¯å‡½æ•°)
    - [ğŸˆå®šä¹‰](#å®šä¹‰)
    - [ğŸˆæ€§è´¨](#æ€§è´¨)
    - [ğŸˆåˆ©ç”¨](#åˆ©ç”¨)
    - [ğŸˆç¨‹åº](#ç¨‹åº)
- [ğŸ“•æ¦‚è¿°](#æ¦‚è¿°)
    - [ğŸˆæ¦‚å¿µ](#æ¦‚å¿µ)
    - [ğŸˆæ€æƒ³](#æ€æƒ³)
    - [ğŸˆåæ¼”å®šç†](#åæ¼”å®šç†)
- [ğŸ“•å®ä¾‹](#å®ä¾‹)
    - [ğŸˆé¢˜ç›®](#é¢˜ç›®)
    - [ğŸˆæ€è·¯](#æ€è·¯)
    - [ğŸˆç¨‹åº](#ç¨‹åº-1)
  
# ğŸ“•å‰ç½®èŠå£« â€”â€” è«æ¯”ä¹Œæ–¯å‡½æ•°
### ğŸˆå®šä¹‰
$$
Î¼(n) =
\begin{cases}
1      & n = 1 \\
(-1)^k   & næ— å¹³æ–¹å› æ•°ï¼Œn = p_1p_2p_3...p_k \\
0          & næœ‰å¤§äº1çš„å¹³æ–¹å› æ•° \\
\end{cases}
$$
å¯ä»¥ç®€åŒ–ä¸ºï¼š
åœ¨næ— å¹³æ–¹å› æ•°æ—¶ï¼š$Î¼(n) = (-1)^{nçš„ä¸åŒè´¨å› å­çš„ä¸ªæ•°}$
å…¶ä»–æƒ…å†µï¼š$\qquad\;\;\;Î¼(n) = 0$
### ğŸˆæ€§è´¨
æ­£å¸¸æƒ…å†µä¸‹åœ¨næœ‰xæ•°ä¸ªä¸åŒè´¨å› å­ï¼Œmæœ‰yæ•°ä¸ªä¸åŒè´¨å› å­æ—¶
1.xå¥‡ï¼Œyå¥‡ï¼Œn * mçš„è´¨å› å­ä¸ªæ•° = x + y = å¶ï¼Œ$Î¼(n) * Î¼(m) = (-1) * (-1) = 1$
2.xå¥‡ï¼Œyå¶ï¼Œn * mçš„è´¨å› å­ä¸ªæ•° = x + y = å¥‡ï¼Œ$Î¼(n) * Î¼(m) = (-1) * \quad1 \;\;= -1$
3.xå¶ï¼Œyå¥‡ï¼Œn * mçš„è´¨å› å­ä¸ªæ•° = x + y = å¥‡ï¼Œ$Î¼(n) * Î¼(m) = \quad1 \;\;* (-1) = -1$
4.xå¶ï¼Œyå¶ï¼Œn * mçš„è´¨å› å­ä¸ªæ•° = x + y = å¶ï¼Œ$Î¼(n) * Î¼(m) = \quad1 \;\;* \quad1 \;\;= 1$
å¯ä»¥çœ‹å‡ºè«æ¯”ä¹Œæ–¯å‡½æ•°æ˜¯ä¸ªç§¯æ€§å‡½æ•°

ä½†æ˜¯ç‰¹æ®Šæƒ…å†µä¾‹å¦‚$n = m = 2$æ—¶
$Î¼(n) = Î¼(m) = -1$
$Î¼(n * m) = 0\;\;!= (-1) * (-1) = Î¼(n) * Î¼(m)$
æ‰€ä»¥è«æ¯”ä¹Œæ–¯å‡½æ•°ä¸æ˜¯å®Œå…¨ç§¯æ€§å‡½æ•°

### ğŸˆåˆ©ç”¨
$$\sum_{d\mid n}^{}Î¼(d) = [n = 1]$$
ä¾‹å¦‚ n = 12æ—¶
$$\sum_{d\mid 12}^{}Î¼(12) =Î¼(1)+Î¼(2)+Î¼(3)+Î¼(4)+Î¼(6)+Î¼(12) = 1 + (-1) + 1 + 0 + 1 + 0$$
### ğŸˆç¨‹åº
çº¿æ€§ç­›æ‰“è¡¨ï¼š
```cpp
const int maxn = 2005;

bool isprime[maxn];
ll mu[maxn];//Mobiuså‡½æ•°è¡¨
vector<ll> prime;

inline void Mobius(){//çº¿æ€§ç­›
        isprime[0] = isprime[1] = 1;
        mu[1] = 1;//ç‰¹åˆ¤mu[i] = 1
        for(ll i = 2; i <= maxn; i ++){
                if( !isprime[i] ) mu[i] = -1, prime.push_back(i);//è´¨æ•°çš„è´¨å› å­åªæœ‰è‡ªå·±ï¼Œæ‰€ä»¥ä¸º-1
                for(ll j = 0; j < prime.size() && i * prime[j] <= maxn; j ++){
                        isprime[i * prime[j]] = 1;
                        if(i % prime[j] == 0) break;
                        mu[i * prime[j]] = -mu[i];//ç§¯æ€§å‡½æ•°æ€§è´¨ï¼š (i * prime[j])å¤šå‡ºæ¥ä¸€ä¸ªè´¨æ•°å› æ•°(prime[j])ï¼Œä¿®æ­£ä¸º (-1) * mu[i]
                }
        }
        //å‰©ä½™çš„æ²¡ç­›åˆ°çš„æ˜¯å…¶ä»–æƒ…å†µï¼Œä¸º0
}
```

# ğŸ“•æ¦‚è¿°
### ğŸˆæ¦‚å¿µ
è«åæ˜¯ä¸€ç§åˆ©ç”¨è«æ¯”ä¹Œæ–¯å‡½æ•°çš„ç§¯æ€§æ€§è´¨ï¼Œå¯¹æ–¹ç¨‹è¿›è¡Œè®¡ç®—ç”¨æ—¶ç®€åŒ–çš„ä¸€ç§æ–¹æ³•
### ğŸˆæ€æƒ³
ï¼ˆä¸Šæ–‡ä¸­æ€§è´¨çš„åˆ©ç”¨ï¼‰
### ğŸˆåæ¼”å®šç†
è®¾æœ‰ä¸¤ä¸ªæ–¹ç¨‹$f(x)$å’Œ$F(x)$ï¼Œæœ‰ä»¥ä¸‹ä¸¤ç§åæ¼”æ–¹å¼

1.$$F(n) = \sum_{d|n}f(d)$$$$\Downarrow$$$$f(n) = \sum_{d|n}{}Î¼(d)F(\frac nd)$$
>è¯æ˜ï¼š
>$$\sum_{d|n}\mu(d)F(\frac nd) = \sum_{d|n}\mu(d)\sum_{i|\frac nd}f(i) = \sum_{i|n}f(i)\sum_{d|\frac ni}\mu(d) = f(n)$$

2.$$F(n) = \sum_{n|d}f(d)$$$$\Downarrow$$$$f(n) = \sum_{n|d}{}Î¼(\frac dn)F(d)$$
>è¯æ˜
>$$\sum_{n|d}\mu(\frac dn)F(d) = \sum_{n|d}\mu(\frac dn)\sum_{d|i}f(n)=(d' = \frac dn)\sum_{n|i}f(i)\sum_{d'|\frac in}\mu(d') = f(n)$$

# ğŸ“•å®ä¾‹
### ğŸˆé¢˜ç›®
[UVA10214 ã€ŠTrees in a Wood.ã€‹ä¼ é€é—¨](https://vjudge.net/problem/UVA-10214)
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20210606161231327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Nub3B6WXo=,size_16,color_FFFFFF,t_70)
### ğŸˆæ€è·¯
ä¸[[SDOI2008]ä»ªä»—é˜Ÿ](https://www.luogu.com.cn/problem/P2158)å¾ˆåƒ
åœ¨ä¸€ä¸ªè±¡é™å†…
éƒ½æ˜¯è®©æ±‚
$$\sum_{i = 1}^{N}\sum_{j=1}^{M}[gcd(i,j)=1] $$
æ‰€ä»¥æˆ‘ä»¬è®¾ç½®$$f(n) = \sum_{i = 1}^{N}\sum_{j=1}^{M}[gcd(i,j)=n],\quad f(1) = \;?$$
ä½†æ˜¯å› ä¸º$f(1)$æ¯”è¾ƒéš¾æ±‚ï¼Œæ‰€ä»¥æˆ‘ä»¬åŒæ—¶è¦è®¾ç½®ä¸€ä¸ªæ»¡è¶³$F(n) = \sum_{n|d}f(d)$çš„$F(n)$
$$F(n) = \sum_{i = 1}^{N}\sum_{j=1}^{M}[n | gcd(i,j)],\quad F(1) =  \sum_{i = 1}^{N}\sum_{j=1}^{M}1$$
$$\therefore F(n) = \sum_{n|d}f(d),\quad F(1) = \sum_{d = 1}^{min(N,M)}f(d)$$
$$\therefore f(n) = \sum_{n|d}\mu(\frac dn)F(d),\quad f(1) = \sum_{d=1}^{min(N,M)}\mu(d)F(d)$$
$$\because 1 \le d \le min(N, M)$$
$$\therefore F(d) = \left \lfloor \frac Nd \right \rfloor * \left \lfloor \frac Md \right \rfloor $$
$$\therefore f(1) = \sum_{d=1}^{min(N,M)}\mu(d) * \left \lfloor \frac Nd \right \rfloor * \left \lfloor \frac Md \right \rfloor $$
ç”±äºå››ä¸ªè±¡é™ + å››ä¸ªåæ ‡è½´ï¼Œæ‰€ä»¥åˆ†å­ä¸º$4 * \sum_{d = 1}^{min(N, M)}Î¼(d)*\left \lfloor \frac nd \right \rfloor *\left \lfloor \frac md \right \rfloor + 4$
åˆ†æ¯åˆ™æ˜¯æ‰€æœ‰çš„æ ‘ $(N * 2 + 1) * (M * 2 + 1) - 1$

ç­”æ¡ˆåˆ™æ˜¯$\frac {4 * \sum_{d = 1}^{min(N, M)}Î¼(d)*\left \lfloor \frac nd \right \rfloor *\left \lfloor \frac md \right \rfloor + 4}{(N * 2 + 1) * (M * 2 + 1) - 1}$ä¿ç•™7ä½å°æ•°
### ğŸˆç¨‹åº
```cpp
/*
           ________   _                                              ________                              _
          /  ______| | |                                            |   __   |                            | |
         /  /        | |                                            |  |__|  |                            | |
         |  |        | |___    _   _   _   ___  _   _____           |     ___|   ______   _____   ___  _  | |
         |  |        |  __ \  |_| | | | | |  _\| | | ____|          |  |\  \    |  __  | |  _  | |  _\| | | |
         |  |        | |  \ |  _  | | | | | | \  | | \___           |  | \  \   | |_/ _| | |_| | | | \  | | |
         \  \______  | |  | | | | \ |_| / | |_/  |  ___/ |          |  |  \  \  |    /_   \__  | | |_/  | | |
Author :  \________| |_|  |_| |_|  \___/  |___/|_| |_____| _________|__|   \__\ |______|     | | |___/|_| |_|
                                                                                         ____| |
                                                                                         \_____/
*/
#include <unordered_map>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <utility>
#include <string>
#include <vector>
#include <cstdio>
#include <stack>
#include <queue>
#include <cmath>
#include <map>
#include <set>

#define G 10.0
#define LNF 1e18
#define EPS 1e-6
#define PI acos(-1.0)
#define INF 0x7FFFFFFF

#define ll long long
#define ull unsigned long long

#define LOWBIT(x) ((x) & (-x))
#define LOWBD(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()
#define UPPBD(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()
#define TEST(a) cout << "---------" << a << "---------" << '\n'

#define CHIVAS_ int main()
#define _REGAL exit(0)

#define SP system("pause")
#define IOS ios::sync_with_stdio(false)
//#define map unordered_map

#define _int(a) int a; cin >> a
#define  _ll(a) ll a; cin >> a
#define _char(a) char a; cin >> a
#define _string(a) string a; cin >> a
#define _vectorInt(a, n) vector<int>a(n); cin >> a
#define _vectorLL(a, b) vector<ll>a(n); cin >> a

#define PB(x) push_back(x)
#define ALL(a) a.begin(),a.end()
#define MEM(a, b) memset(a, b, sizeof(a))
#define EACH_CASE(cass) for (cin >> cass; cass; cass--)

#define LS l, mid, rt << 1
#define RS mid + 1, r, rt << 1 | 1
#define GETMID (l + r) >> 1

using namespace std;

template<typename T> inline void Read(T &x){T f = 1; x = 0;char s = getchar();while(s < '0' || s > '9'){if(s == '-') f = -1; s = getchar();}while('0'<=s&&s<='9'){x=(x<<3)+(x<<1)+(s^48);s=getchar();}x*=f;}
template<typename T> inline T MAX(T a, T b){return a > b? a : b;}
template<typename T> inline T MIN(T a, T b){return a > b? b : a;}
template<typename T> inline void SWAP(T &a, T &b){T tp = a; a = b; b = tp;}
template<typename T> inline T GCD(T a, T b){return b > 0? GCD(b, a % b) : a;}
template<typename T> inline void ADD_TO_VEC_int(T &n, vector<T> &vec){vec.clear(); cin >> n; for(int i = 0; i < n; i ++){T x; cin >> x, vec.PB(x);}}
template<typename T> inline pair<T, T> MaxInVector_ll(vector<T> vec){T MaxVal = -LNF, MaxId = 0;for(int i = 0; i < (int)vec.size(); i ++) if(MaxVal < vec[i]) MaxVal = vec[i], MaxId = i; return {MaxVal, MaxId};}
template<typename T> inline pair<T, T> MinInVector_ll(vector<T> vec){T MinVal = LNF, MinId = 0;for(int i = 0; i < (int)vec.size(); i ++) if(MinVal > vec[i]) MinVal = vec[i], MinId = i; return {MinVal, MinId};}
template<typename T> inline pair<T, T> MaxInVector_int(vector<T> vec){T MaxVal = -INF, MaxId = 0;for(int i = 0; i < (int)vec.size(); i ++) if(MaxVal < vec[i]) MaxVal = vec[i], MaxId = i; return {MaxVal, MaxId};}
template<typename T> inline pair<T, T> MinInVector_int(vector<T> vec){T MinVal = INF, MinId = 0;for(int i = 0; i < (int)vec.size(); i ++) if(MinVal > vec[i]) MinVal = vec[i], MinId = i; return {MinVal, MinId};}
template<typename T> inline pair<map<T, T>, vector<T> > DIV(T n){T nn = n;map<T, T> cnt;vector<T> div;for(ll i = 2; i * i <= nn; i ++){while(n % i == 0){if(!cnt[i]) div.push_back(i);cnt[i] ++;n /= i;}}if(n != 1){if(!cnt[n]) div.push_back(n);cnt[n] ++;n /= n;}return {cnt, div};}
template<typename T>             vector<T>& operator--            (vector<T> &v){for (auto& i : v) --i;            return  v;}
template<typename T>             vector<T>& operator++            (vector<T> &v){for (auto& i : v) ++i;            return  v;}
template<typename T>             istream& operator>>(istream& is,  vector<T> &v){for (auto& i : v) is >> i;        return is;}
template<typename T>             ostream& operator<<(ostream& os,  vector<T>  v){for (auto& i : v) os << i << ' '; return os;}

const int maxn = 2005;

bool isprime[maxn];
ll mu[maxn];//Mobiuså‡½æ•°è¡¨
ll n, m;
vector<ll> prime;

inline void Mobius(){//çº¿æ€§ç­›
        isprime[0] = isprime[1] = 1;
        mu[1] = 1;//ç‰¹åˆ¤mu[i] = 1
        for(ll i = 2; i <= maxn; i ++){
                if( !isprime[i] ) mu[i] = -1, prime.push_back(i);//è´¨æ•°çš„è´¨å› å­åªæœ‰è‡ªå·±ï¼Œæ‰€ä»¥ä¸º-1
                for(ll j = 0; j < prime.size() && i * prime[j] <= maxn; j ++){
                        isprime[i * prime[j]] = 1;
                        if(i % prime[j] == 0) break;
                        mu[i * prime[j]] = -mu[i];//ç§¯æ€§å‡½æ•°æ€§è´¨ï¼š (i * prime[j])å¤šå‡ºæ¥ä¸€ä¸ªè´¨æ•°å› æ•°(prime[j])ï¼Œä¿®æ­£ä¸º (-1) * mu[i]
                }
        }
        //å‰©ä½™çš„æ²¡ç­›åˆ°çš„æ˜¯å…¶ä»–æƒ…å†µï¼Œä¸º0
}

inline void solve(){
        ll res = 0;
        for(ll d = 1; d <= MIN(n, m); d ++){
                res += mu[d] * (n / d) * (m / d);
        }
        res = res * 4 + 4;//å››ä¸ªè±¡é™ + åæ ‡è½´çš„å››ä¸ªè´¡çŒ®
        ll down = (n * 2 + 1) * (m * 2 + 1) - 1;//åˆ†æ¯ï¼ŒçŸ©é˜µæ‰€æœ‰æ ‘ - åŸç‚¹
        printf("%.7f\n", res * 1.0 / down);
}

CHIVAS_{Mobius();
        while(scanf("%lld%lld", &n, &m) == 2, n || m){
                solve();
        }
        _REGAL;
}
```
