- [DIJKSTRA](#dijkstra)
  - [基本思想](#基本思想)
  - [注意事项](#注意事项)
  - [松弛操作](#松弛操作)
  - [例题](#例题)
- [FLoyd(插点法，经典DP)](#floyd插点法经典dp)
  - [算法思想](#算法思想)
  - [算法特点](#算法特点)
  - [难点思考](#难点思考)
- [Bellman-Ford](#bellman-ford)
  - [算法思想](#算法思想-1)
  - [算法特点：](#算法特点-1)
  - [难点思考](#难点思考-1)
- [Bellman_Ford算法队列优化（SPFA）](#bellman_ford算法队列优化spfa)
  - [基本思想](#基本思想-1)
  - [具体操作](#具体操作)
- [优缺点总结](#优缺点总结)

</br></br></br></br></br></br></br></br>
<div style="border: 1px dashed black;">回顾：链式前向星(邻接表的数组实现)

```
struct edge{ int nxt, to, dis; }edge[N];
int head[N];
int cnt = 0;

inline void add_edge(int from, int to, int val){
	edge[++cnt] = {head[from], to, val};
	head[from] = cnt;
}

inline void input(){
	for(int i = 1, x, y, z; i <= m; i ++){
		read(x); read(y); read(z);
		add_edge(x, y, z);
	}
}

inline void run(){
	for(int i = 1; i <= n; i ++){
		for(int k = head[k]; ~k; k = edge[k].nxt){
			//
		}
	}
}
```
</div>



# DIJKSTRA
## 基本思想
<ul>
	<li>按照<span style="color:red;">最短路径长度</span>递增的次序，依次求的——源点到其余各点到最短路径</li>
	<li>先求——最短的那条最短路径</li>
	<li>再求——第二短的最短路径</li>
	<li>......</li>
	<li>依次类推</li>
	<li>......</li>
	<li>最终求出所有的最短路径</li>
</ul>
## 注意事项
如果无向图要建立反边
如果多条路要选择最短
## 松弛操作

```
if(Dis[x] + edge[i].val < Dis[edge[i].to]) 
	Dis[edge[i].to] = Dis[x] + edge[i].val,
	pque.push({edge[i].to, Dis[edge[i].to]});
```
其实就是看看从这个中转站转一下会不会更近
## 例题
>求任意两点的最短路
可以采用的算法：DIJKSTRA？FLoyd!

# FLoyd(插点法，经典DP)

```
for(int k = 1; k <= n; k ++)        //插入点在外层循环很重要！
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= n; j ++)
			dis[i][j] = MIN(dis[i][j], dis[i][k] + dis[k][j]);
```
## 算法思想
从i到j的只经过<span style="color: red;">前k个点</span>的最短路径</br>
## 算法特点
简单、粗暴、易于实现、可以解决<span style="color: red;">负权</span>
## 难点思考
<span style="color: red;">三重循环是否可以任意交换顺序？</span></br>
如果k放里面的话，我们在MIN更新中用到的dis[i][k]、dis[k][j]不一定是最优解，因为前面并没有更新过

# Bellman-Ford

```
//数据存储结构？
for(int k = 1; k < n; k ++){       //n - 1个阶段，每个阶段的效果？
	for(int i = 1; i <= m; i ++){  //每个阶段，对所有边尝试松弛
		dis[v[i]] = MIN(dis[v[i]], dis[u[i]] + w[i]);
	}
}
```

## 算法思想
一共n个点，所构成最短一条最多n-1条边</br>
每次松弛都只能完善m个中的一部分边</br>
要想完善完所有m条边</br>
我们要对<span style="color:red;">所有的边</span>进行n-1次松弛操作
## 算法特点：
简洁、可以解决<span style="color:red;">负权负环</span>的情况</br>
>其实并不一定需要n-1轮，如果前面的点都没做过松弛操作，那么这一趟松弛操作并不会更新，就不需要继续进行（冒泡排序思想）

## 难点思考
如何检测是否存在负环？</br>
如果在某两点内走会不断减权，那么就有负环</br>

```
for(int k = 1; k <= n - 1; k ++)
	for(int i = 1; i <= m; i ++)
		dis[v[i]] = MIN(dis[v[i]], dis[u[i]] + w[i]);

//正常情况下，做了n-1趟松弛操作后整个图的最优解就稳定了，如果还有可以松弛的，就是负环
int flag = 0;
for(int i = 1; i <= m; i ++)
	if(dis[v[i]] > dis[u[i]] + w[i]) flag = 1;
if(flag) ... //有负环的情况
```

# Bellman_Ford算法队列优化（SPFA）
## 基本思想
每次仅对最短路程发生变化了的点的相邻边执行松弛操作</br>
<span style="color:red;">问题：</span>如何知道当前哪些点的最短路程发生了变化呢？</br>
<span style="color:red;">方案：</span>采用“队列“维护
## 具体操作
先把起点加进队列中，然后松弛和起点相连的所有边，如果松弛成功且该点不在队列中，那么就把这个点入队。然后依次取出队列中每一个点进行松弛，直到队列为空。

```
inline void SPFA(int u){
	que.push(u); vis[u] = 1;
	while(que.size()){
		int x = que.front(); que.pop(); vis[x] = 0;
		for(int i = head[x]; ~i; i = edge[i].nxt){
			int y = edge[i].to;
			if(dis[x] + edge[i].val < dis[y]){
				dis[y] = dis[x] + edge[i].val;
				if(!vis[y]) vis[y] = 1, que.push(y);
			}
		}
	}
}
```

# 优缺点总结
<span style="color:red;">DIJKSTRA</span></br>
优点：大数据单源最短路求解</br>
缺点：负环不能求</br>
<span style="color:red;">FLoyd</span></br>
优点：擅长求任意两点最短路</br>
缺点：时间复杂度高</br>
<span style="color:red;">Bellman-Ford(SPFA)</span></br>
优点：求负环问题</br>
缺点：最坏情况复杂度高
