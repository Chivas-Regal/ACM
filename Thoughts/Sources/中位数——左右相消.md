# 中位数——左右相消  
  
对于一个完美中位数，左右的数的数量是相等的  
那么此时我们就可以利用这个性质来判断一个数列中分成m段  
m个b[i]能不能都作为这个数列的完美中位数  

那么就是对于剩下的几个用不到的工具段  
每一段变成这一段数的个数存到数组内  
问这个数组可不可以两两相消的情况下变成全0  
  
这就是左右相消的应用  

## 例题

<a href="https://acm.dingbacode.com/showproblem.php?pid=7029">HDU2021多校(6)5_Median</a>  
```cpp
struct node { int val, op; inline friend bool operator < (node a, node b) { return a.val - a.op < b.val - b.op; } };

const int N = 1e5 + 10;
int a[N], n, m;

inline void Solve () {
        scanf("%d%d", &n, &m);
        priority_queue<node> pque;
        for ( int i = 0; i < m; i ++ ) cin >> a[i];
        sort ( a, a + m );
        for ( int i = 0; i < m; i ++ ) {
                if ( i == 0     && a[i] > 1 )   pque.push({a[i] - 1, 0});
                if ( i == m - 1 && a[i] < n )   pque.push({n - a[i], m});
                if ( i && a[i] > a[i - 1] + 1 ) pque.push({a[i] - a[i - 1] - 1, i});
        }
        while ( pque.size() >= 2 ) {
                node fir = pque.top(); pque.pop();
                node sec = pque.top(); pque.pop();
                fir.val --; sec.val --;
                if ( fir.val ) pque.push(fir);
                if ( sec.val ) pque.push(sec);
        } 
        if ( !pque.size() ) puts("YES");
        else {
                node x = pque.top();
                if ( x.val - x.op > 0 ) puts("NO");
                else                    puts("YES");
        }
}

int main () {
        int cass; scanf("%d", &cass); while ( cass -- ) {
                Solve();
        }
}
```
