# 🔗
<a href="https://www.luogu.com.cn/problem/P1050"><img src="https://user-images.githubusercontent.com/78973908/139773613-536b48d2-1521-4cd1-b536-0976380ac659.png"></a>

# 💡
暴力地求k位成为循环节非常麻烦  
那么考虑两点：  
1.每次对于一位求得循环节很简单  
2.对于同一个n，k从小到大得到的结果互相有联系  
  
首先第一个考虑：  
在一位的基础上求，这一位每次乘一个数，如果十次之后不成循环就不行了  
然后第二个考虑：  
比如k=3时，循环节长度为len3，k=2，循环节长度为len2  
len3必定是len2的倍数，因为k=3时，为了保证k=2成循环节，那么len3必定是在基于k=2上跳多少次len2  
所以len3是len2的倍数  
而这个倍数就是在只针对第3位时求得的结果  
  
那么对于n就从[1,k]枚举后面的长度  
每次我们可以将当前求得的这个循环节长度作为指数累放到n每次要乘的数上  
这样可以实现直接跳跃过这个区间，从而保证之前算过的位保持循环节  
我们就可以只专心管理当前计算的位  

```
n = 8123, k = 4

8123           1
8123*8123=3129 2
3129*8123=6867 3
6867*8123=0641 4
0641*8123=6843 #
8123^4=0641

8123           1
8123*0641=6843 2
6843*0641=6363 3
6363*0641=8683 4
8683*0641=5803 5
5803*0641=9723 #
0641^5=9201
(注意此时最后一位就是一直不变） 

8123           1
8123*9201=9723 2
9723*9201=1323 3
1323*9201=2923 4
2923*9201=4523 5
4523*9201=6123 #
9201^5=6001
(注意此时最后两位不变）

8123           1
8123*6001=6123 2
6123*6001=4123 3
4123*6001=2123 4
2123*6001=0123 5
0123*6001=8123 #
(最后就是后三位不变了）

res=4*5*5*5=500
```
当然如果在某一位出现-1了那么整个就不行  
就输出-1  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
public class Main {
        public static BigInteger one = BigInteger.ONE;
        public static BigInteger zero = BigInteger.ZERO;
        public static BigInteger two = BigInteger.valueOf(2);
        public static BigInteger ten = BigInteger.TEN;
        public static BigInteger ksm ( BigInteger a, BigInteger b ) {
                BigInteger res = BigInteger.ONE;
                while ( b.compareTo(zero) == 1 ) {
                        if ( b.mod(two).compareTo(one) == 0 ) {
                                res = res.multiply(a);
                        }
                        a = a.multiply(a);
                        b = b.divide(two);
                }
                return res;
        }
        public static BigInteger Solve ( BigInteger n, BigInteger k, BigInteger mul /* 每次乘的数，实现跳步 */ ) { // 针对第k位得到的分解后的循环节长度
                BigInteger mo = ksm(ten, k);
                n = n.mod(mo);
                BigInteger nn = n;
                for ( int i = 1; i <= 100; i ++ ) {
                        n = n.multiply(mul).mod(mo);
                        if ( n.compareTo(nn) == 0 ) return BigInteger.valueOf(i);
                }
                return BigInteger.valueOf(-1);
        }
        public static void main (String[] args) {
                Scanner input = new Scanner(System.in);
                BigInteger n = input.nextBigInteger ();
                BigInteger k = input.nextBigInteger ();
                BigInteger lst = one; // 实时更新每一位得到的结果
                BigInteger res = one; // 总答案
                BigInteger cur = n;   // 每次n要乘的数（区间跳跃
                for ( BigInteger i = one; i.compareTo(k) <= 0; i = i.add(one) ) {
                        cur = ksm(cur, lst).mod(ksm(ten, k));
                        lst = Solve(n, i, cur);
                        if ( i.compareTo(k) == 0 ) {
                                if ( lst.compareTo(zero) < 0 ) System.out.println("-1");
                                else                           System.out.println(lst.multiply(res));
                                return;
                        }
                        if ( lst.compareTo(zero) < 0 ) {
                                System.out.println("-1");
                                return;
                        }
                        res = res.multiply(lst);
                }
                input.close();
        }
}
```
