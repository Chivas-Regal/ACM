# 🔗
<a href="https://www.luogu.com.cn/problem/P1131"><img src="https://i.loli.net/2021/11/08/4ekjQZhzdpCwHvg.png"></a>

# 💡
~~很灵活的题，想到这个懒标记解法感觉很妙，想了这么久果然还是wtcl~~  
### 问题转换
 <img src="https://latex.codecogs.com/svg.image?\inline&space;1." title="\inline 1." />  简化一下任务，一个有根树  
**在边上改变最少的全值让根到叶子节点的距离相同**  

 <img src="https://latex.codecogs.com/svg.image?\inline&space;2." title="\inline 2." />  因为边权只能加不能减，那么再简化一下任务  
利用差分的思想将每个叶子节点与根节点的距离  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis[i]" title="\inline dis[i]" />  设置为这个距离与最远叶子节点距离的差值即  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis[i]=max\_dis-dis[i]" title="\inline dis[i]=max\_dis-dis[i]" />   
**我们要让所有叶子节点的  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis[i]=0" title="\inline dis[i]=0" />**

### 解题思路
纸上试推一下我们不难发现：  
每一个边权的增加  <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  会让这个边权下面的子树上所有叶子节点的  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis" title="\inline dis" />  同加 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  
也就是我们转换后的  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis[i]" title="\inline dis[i]" />  同减 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  

**而这种做法是很划算的，因为我们只需要减一次就能对很多叶子节点产生影响**  

但是要注意，不能减成负数了  
因为减成负数了话还要在后面的过程中对很多子树的叶子节点再减些值补到一样，很不划算  

**所以我们的每棵子树所能减的最多的值是有一个限制的，也就是这颗子树上所有叶子节点  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis" title="\inline dis" />  的最小值**，这显然是可以直接预处理出来的，设为  <img src="https://latex.codecogs.com/svg.image?\inline&space;min\_val" title="\inline min\_val" />   
这样看来似乎还是有些难以解决  
那么就是想到了**懒标记**的处理方式  
因为在往下推子树的时候，是子树减 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" /> ，这样的话子树的最小值也会减 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  
因为在枚举到一个节点 <img src="https://latex.codecogs.com/svg.image?\inline&space;a" title="\inline a" /> 的时候，要让这颗子树的最小值 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" /> 减到  <img src="https://latex.codecogs.com/svg.image?\inline&space;0" title="\inline 0" />  ，而**减的时候我们孙子节点 <img src="https://latex.codecogs.com/svg.image?\inline&space;c" title="\inline c" /> 是可以先放着不管**的，那么就是让儿子节点 <img src="https://latex.codecogs.com/svg.image?\inline&space;b" title="\inline b" /> 减去这个 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  

<img src="https://latex.codecogs.com/svg.image?\inline&space;c" title="\inline c" /> 节点什么时候减呢？那就是在枚举到 <img src="https://latex.codecogs.com/svg.image?\inline&space;b" title="\inline b" /> 节点的时候，会让这个 <img src="https://latex.codecogs.com/svg.image?\inline&space;c" title="\inline c" /> 节点下减  
减得少了怎么办？毕竟 <img src="https://latex.codecogs.com/svg.image?\inline&space;a" title="\inline a" /> 可是子树减过了，不能不算吧？诶**我们懒标记累加一下减的值，在 <img src="https://latex.codecogs.com/svg.image?\inline&space;c" title="\inline c" /> 节点减的时候给它算上**不就行了  
**我们每次答案要加的值就是我们在每一个节点上要子树减的值**  

就是这样一个顺序  
![](https://i.loli.net/2021/11/07/rsyNfQBzqAIDcKE.png)
  
那么这一题完整的思想就出来了  

### 程序框架

|----预处理叶子节点与根节点距离  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis" title="\inline dis" />  数组  
|----将 <img src="https://latex.codecogs.com/svg.image?\inline&space;dis" title="\inline dis" /> 数组差分化  
|--------求  <img src="https://latex.codecogs.com/svg.image?\inline&space;max\{dis\}" title="\inline max\{dis\}" />   
|--------  <img src="https://latex.codecogs.com/svg.image?\inline&space;dis[i]=max\{dis\}-dis[i]" title="\inline dis[i]=max\{dis\}-dis[i]" />   
|----预处理子树最小叶子 <img src="https://latex.codecogs.com/svg.image?\inline&space;dis" title="\inline dis" /> 的 <img src="https://latex.codecogs.com/svg.image?\inline&space;min\_val" title="\inline min\_val" /> 数组  
|----懒标记递推  <img src="https://latex.codecogs.com/svg.image?\inline&space;dfs" title="\inline dfs" />   
|--------每个节点的 <img src="https://latex.codecogs.com/svg.image?\inline&space;min\_val" title="\inline min\_val" /> 加给 <img src="https://latex.codecogs.com/svg.image?\inline&space;lazy" title="\inline lazy" />  
|--------儿子节点的 <img src="https://latex.codecogs.com/svg.image?\inline&space;min\_val" title="\inline min\_val" /> 同减 <img src="https://latex.codecogs.com/svg.image?\inline&space;lazy" title="\inline lazy" />   
|--------答案累加该节点的 <img src="https://latex.codecogs.com/svg.image?\inline&space;min\_val" title="\inline min\_val" />  
|----输出答案

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
namespace Map { // 存图
        const int M = 1e6 + 10;
        struct Edge {
                int nxt, to;
                ll val;
        } edge[M];
        int head[M], cnt;

        inline void add_Edge ( int from, int to, ll val ) {
                edge [ ++ cnt ] = { head[from], to, val };
                head[from] = cnt;
        }

} using namespace Map;

int n, a, b, m;
ll res, t;

namespace TreeHasRoot {
        const int N = 5e5 + 10;
        ll dis[N], min_val[N]; // 距离，子树最小dis
        vector<int> leaves; // 叶子节点数组
        inline void pre_Dis ( int x, int fath ) {  // 预处理直接距离dis
                int cnt = 0;
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fath ) continue;
                        dis[to] = dis[x] + edge[i].val;
                        pre_Dis ( to, x );
                        cnt ++;
                }
                if ( !cnt ) leaves.push_back(x); // 没有儿子，是叶子节点！
        }
        inline void get_dir_dis () { //将dis数组差分化
                pre_Dis (m, m);
                ll mx = 0;
                for ( auto i : leaves ) mx = max ( mx, dis[i] );
                for ( auto i : leaves ) dis[i] = mx - dis[i];
        }
        inline void pre_MinVal ( int x, int fath ) { // 预处理min_val数组
                min_val[x] = 0x3f3f3f3f;
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fath ) continue;
                        pre_MinVal ( to, x );
                        min_val[x] = min ( min_val[x], min_val[to] );
                }
                if ( min_val[x] == 0x3f3f3f3f ) min_val[x] = dis[x]; // 是子节点！设置为本身就行了
        }
        inline void Solve ( int lazy, int x, int fath ) {
                lazy += min_val[x]; // 递推懒标记
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fath ) continue; 
                        min_val[to] -= lazy; // 儿子同减lazy
                        Solve ( lazy, to, x );
                }
                res += min_val[x]; // 答案累加这一次子树减的值
        }
} using namespace TreeHasRoot;


int main () {
        cin >> n >> m;
        for ( int i = 0; i < n - 1; i ++ ) {
                cin >> a >> b >> t;
                add_Edge ( a, b, t );
                add_Edge ( b, a, t ); 
        }

        get_dir_dis ();
        pre_MinVal ( m, m );
        
        for ( int i = head[m]; i; i = edge[i].nxt ) Solve ( 0, edge[i].to, m ); // 注意根节点上面没有边，没法子树减
        cout << res << endl;
}
```
