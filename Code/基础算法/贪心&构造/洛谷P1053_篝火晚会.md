# 🔗
<a href="https://www.luogu.com.cn/problem/P1053"><img src="https://i.loli.net/2021/11/08/CDFo8qQvL4PfZpH.png"></a>

# 💡
一个序列整体变动成为另一个序列的话，最大的不动量是与目标位置距离相同的点个数  
  
首先对这个要求，我们先建立出来一条链  
同时如果一个点的好朋友不把它当作好朋友，就肯定是  <img src="https://latex.codecogs.com/svg.image?\inline&space;-1" title="\inline -1" />  
这个可以在建链的时候检查一下  
  
建完之后就对这个距离统计一下数值，看看最多的是多少个点距离相同  
（注意，距离有正反，因为这是个链）  
然后  <img src="https://latex.codecogs.com/svg.image?\inline&space;n" title="\inline n" /> 减掉这个数量就行了  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
class P1053NOIP2005 {
private:
        static const int N = 5e4 + 10;
        int n;
        pair<int, int> pr[N];
        int newlst[N], cnt = 0;
        int dir1[N] = {0}, dir2[N] = {0};
public:
        inline void build () {
                newlst[1] = 1; newlst[2] = pr[1].first; newlst[n] = pr[1].second;
                for ( int i = 3; i < n; i ++ ) {
                        if ( pr[newlst[i - 1]].first == newlst[i - 2] ) 
                                newlst[i] = pr[newlst[i - 1]].second;
                        else if ( pr[newlst[i - 1]].second == newlst[i - 2] ) 
                                newlst[i] = pr[newlst[i - 1]].first;
                }
        }
	inline void solve(std::istream& in, std::ostream& out) {
                in >> n; 
                for ( int i = 1; i <= n; i ++ )
                        in >> pr[i].first >> pr[i].second;
                for ( int i = 1; i <= n; i ++ ) {
                        if ((pr[pr[i].first].first != i && pr[pr[i].first].second != i) ||
                            (pr[pr[i].second].first != i && pr[pr[i].second].second != i)) {
                                out << "-1" << endl;
                                return;
                        }
                }
                build ();
                int res = 0;
                for ( int i = 1; i <= n; i ++ ) {
                        dir1[(newlst[i] - i + n) % n] ++; 
                        dir2[(newlst[i] + i - 1) % n] ++;
                }
                for ( int i = 0; i < n; i ++ ) 
                        res = max ( res, max(dir1[i], dir2[i]) );
                out << n - res << endl;
	}
};

int main() {
	P1053NOIP2005 solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
```
