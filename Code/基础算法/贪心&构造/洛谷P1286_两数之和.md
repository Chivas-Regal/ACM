# 🔗
<a href="https://www.luogu.com.cn/problem/P1286"><img src="https://i.loli.net/2021/10/29/zGeO5NELJIS9W8t.png"></a>

# 💡
首先去计算我们可以得到的  
a[1] = ((a[1] + a[2]) + (a[1] + a[3]) + (a[2] + a[3])) / 2 - (a[2] + a[3])  
对sum[]排序一下我们很容易知道a[1]+a[2]和a[1]+a[3]（就是前两个  
那么a[2]+a[3]最多是sum[n]，那么我们直接枚举即可  
  
我们要求a[i]，可以将a[1~(i-1)]两两构造方式都binary_search一下，如果没有找到的话说明我们枚举得到的a[1]是错的，那么直接否认这一种构造方式  
找的的就erase掉  
然后剩下的最小的就是a[1] + a[i]，我们已知a[1]，那么我们直接求得a[i]就行了  
每次求完a[i]都进行上述的二分erase即可  
如果删完的话说明构造正确  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const ll N = 150;
ll a[N];
vector<ll> sum, tmp;
bool flag;
ll n; 

inline void Solve () {
        for ( ll i = 2; i <= n; i ++ ) {
                a[i] = tmp[1] - a[1];
                for ( ll j = 1; j < i; j ++ ) {
                        if ( !binary_search ( tmp.begin(), tmp.end(), a[j] + a[i]) ) return;
                        tmp.erase(lower_bound(tmp.begin(), tmp.end(), a[i] + a[j]));
                }
        }
        flag = 1;
        for ( ll i = 1; i <= n; i ++ ) cout << a[i] << " "; cout << endl;
}

int main () {
        ios::sync_with_stdio(false);
        while ( cin >> n ) {
                flag = false; sum.clear();
                sum.push_back(-100005); for ( ll i = 1, x; i <= n * (n - 1) / 2; i ++ ) cin >> x, sum.push_back(x);
                sort ( sum.begin(), sum.end() );
                for ( int i = 3; i <= n; i ++ ) {
                        tmp = sum;
                        a[1] = (tmp[1] + tmp[2] + tmp[i]) / 2 - tmp[i];
                        Solve ();
                        if ( flag ) goto end;
                }
                cout << "Impossible" << endl;
                end:;
        }
}
```
