# 🔗
<a href="https://www.acwing.com/problem/content/2821/"><img src="https://i.loli.net/2021/10/05/SFb4XtJDf6WPsmT.png"></a>

# 💡
下标一维，权值一维  
可以利用删除的顺序构建出一个时间轴，那么时间戳就是第三维  
我们可以先求出对于T[j]代表的数构成的逆序对数量  
在获取答案的时候时间戳从小到大进行累加得到每一个删前的答案  
  
下标本就排好了，所以不需要对这个维进行排序  
时间戳我们可以反着建，不删的数最小，这样的话所有没有被删掉的数的时间戳都比当前数要小，就可以直接求树状数组前缀  
  
对于逆序对，在区间被分成两半时  
1.i在前，j在后，a[i]>=a[j]，那么我们每次找的是比a[j]大的，可以两个指针从后往前遍历  
2.i在后，j在前，a[i]<=a[j]，那么我们每次找的是比a[j]小的，可以两个指针从前往后遍历  
然后再合并一下区间即可  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>

using namespace std;

#define ll long long

const int N = 1e5 + 10;
int n, m;
struct Data {
        int a, t, res; // 权值、修改时间戳
}q[N], w[N];
ll res[N]; // 时间戳对应的逆序对数
int pos[N]; // 这个数出现的位置

namespace TreeArray {
        int tr[N];
        inline int lowbit ( int x ) { return x & -x; }
        inline void update ( int x, int val ) { while ( x < N ) tr[x] += val, x += lowbit(x); }
        inline int query ( int x ) { int res = 0; while ( x > 0 ) res += tr[x], x -= lowbit(x); return res; }
} using namespace TreeArray;

inline void merge_Sort ( int l, int r ) {
        if ( l >= r ) return;
        int mid = ( l + r ) >> 1;
        merge_Sort ( l, mid ); merge_Sort ( mid + 1, r );
        
        int i, j, k;
        i = mid, j = r; // i前j后，a[i]>=a[j] 
        while ( i >= l && j >= mid + 1 )
                if ( q[i].a >= q[j].a ) update (q[i].t, 1), i --;
                else                    q[j].res += query ( q[j].t ), j --;
        while ( i >= l )       update ( q[i].t, 1 ), i --;
        while ( j >= mid + 1 ) q[j].res += query ( q[j].t ), j --;
        for ( int k = l; k <= mid; k ++ ) update ( q[k].t, -1 ); 

        i = mid + 1, j = l; // i后j前，a[i]<=a[j]
        while ( i <= r && j <= mid )
                if ( q[i].a <= q[j].a ) update ( q[i].t, 1 ), i ++;
                else                    q[j].res += query ( q[j].t ), j ++;
        while ( i <= r )   update ( q[i].t, 1 ), i ++;
        while ( j <= mid ) q[j].res += query ( q[j].t ), j ++;
        for ( int k = mid + 1; k <= r; k ++ ) update ( q[k].t, -1 );

        i = l, j = mid + 1, k = 0;
        while ( i <= mid && j <= r )
                if ( q[i].a <= q[j].a ) w[k ++] = q[i ++];
                else                    w[k ++] = q[j ++];
        while ( i <= mid ) w[k ++] = q[i ++];
        while ( j <= r )   w[k ++] = q[j ++];

        for ( i = 0, j = l; i < k; i ++, j ++ )  q[j] = w[i];
}

int main () {
        ios::sync_with_stdio(false);
#ifndef ONLINE_JUDGE
        freopen("in.in", "r", stdin);
        freopen("out.out", "w", stdout);
#endif
        cin >> n >> m;
        for ( int i = 0; i < n; i ++ )
                cin >> q[i].a,
                pos[q[i].a] = i;

        int k = n;
        for ( int i = 0, x; i < m; i ++ ) 
                cin >> x,
                q[pos[x]].t = k --,
                pos[x] = -1;
        for ( int i = 0; i < n; i ++ )
                if ( pos[q[i].a] != -1 ) q[i].t = k --;
        
        merge_Sort ( 0, n - 1 );
        for ( int i = 0; i < n; i ++ ) res[q[i].t] = q[i].res;
        for ( int i = 2; i <= n; i ++ ) res[i] += res[i - 1]; // 时间戳的值进行累加
        for ( int i = 0, j = n; i < m; i ++, j -- ) cout << res[j] << endl;
}

```
