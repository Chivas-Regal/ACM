# 🔗
<a href="http://poj.org/problem?id=1061"><img src="https://img-blog.csdnimg.cn/9445ccb2dd074747822517694167d4e4.png"></a>

# 💡
我们发现，有一个固定的区间——数轴长度l  
那么我们可以得到一个公式  
<img src="https://latex.codecogs.com/svg.image?X&plus;mx\equiv&space;Y&plus;nx(mod\;l)" title="X+mx\equiv Y+nx(mod\;l)" />  
<img src="https://latex.codecogs.com/svg.image?(m-n)x\equiv&space;Y-X(mod\;l)" title="(m-n)x\equiv Y-X(mod\;l)" />  
即转变为求  
<img src="https://latex.codecogs.com/svg.image?(m-n)x\equiv&space;Y-X(mod\;l)" title="(m-n)x\equiv Y-X(mod\;l)" />   
则设<img src="https://latex.codecogs.com/svg.image?a=m-n,b=l,x,y" title="a=m-n,b=l,x,y" />  
使用扩展欧几里得解方程即可  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <cstdio>
#define ll long long

using namespace std;

inline ll Ex_gcd ( ll a, ll b, ll& x, ll& y ) {
        if ( !b ) { x = 1; y = 0; return a; }
        ll d = Ex_gcd ( b, a % b, x, y );
        ll tmp = x; x = y; y = tmp - (a / b) * y;
        return d;
} 

int main () {
        ll X, Y, m, n, l;
        cin >> X >> Y >> m >> n >> l; // 按要求打入
        ll a = n - m, x, b = l, y, c = X - Y; // 对exgcd的格式做一下转换
        if ( a < 0 ) a = -a, c = -c; // a不可以为负数，因为还要gcd，gcd出来负数就不行了
        ll gcd = Ex_gcd ( a, b, x, y );
        if ( c % gcd ) cout << "Impossible" << endl; // c无法整除gcd
        else {
                c /= gcd, l /= gcd;
                cout << (x * c % l + l ) % l << endl; // 变正数
        }
}
```
