# 🔗
<a href="https://www.luogu.com.cn/problem/P1128"><img src="https://i.loli.net/2021/11/08/PF7LW5UVTGQxbAC.png"></a>

# 💡
**唯一分解定理**  
如果  <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  可以被质因数分解为  <img src="https://latex.codecogs.com/svg.image?\inline&space;x=p_1^{a_1}\times&space;p_2^{a_2}\times&space;p_3^{a_3}\times&space;...\times&space;p_k^{a_k}" title="\inline x=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times ...\times p_k^{a_k}" />   
则  <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" />  的因数个数为  <img src="https://latex.codecogs.com/svg.image?\inline&space;(a_1+1)\times&space;(a_2+1)\times&space;(a_3+1)\times&space;...\times&space;(a_k+1)" title="\inline (a_1+1)\times (a_2+1)\times (a_3+1)\times ...\times (a_k+1)" />   

**解题思路**  
这个题很对应这个定理  
~~所以定理应该能很快想到吧（是吧是吧~~ 

现在给出的是因数个数  <img src="https://latex.codecogs.com/svg.image?\inline&space;n" title="\inline n" /> ，那么我们利用公式贪心地反推一下不就好了吗？   
我们第一反应肯定能想到可以对  <img src="https://latex.codecogs.com/svg.image?\inline&space;n" title="\inline n" />  分解质因数  <img src="https://latex.codecogs.com/svg.image?\inline&space;\{a\}" title="\inline \{a\}" />   
那么每一个质因数  <img src="https://latex.codecogs.com/svg.image?\inline&space;a" title="\inline a" />  都可以有一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;ksm(p,a-1)" title="\inline ksm(p,a-1)" />  来构造我们要求的这个数  <img src="https://latex.codecogs.com/svg.image?\inline&space;m" title="\inline m" />    
根据贪心，我们肯定希望越大的质因数  <img src="https://latex.codecogs.com/svg.image?\inline&space;a" title="\inline a" />  去与越小的质数  <img src="https://latex.codecogs.com/svg.image?\inline&space;p" title="\inline p" />  凑数，这样可以使得  <img src="https://latex.codecogs.com/svg.image?\inline&space;m" title="\inline m" />  更小  
这样的基础共识就是  <img src="https://latex.codecogs.com/svg.image?\inline&space;m=p_1^{(a_1-1)}\times&space;p_2^{(a_2-1)}\times&space;p_3^{(a_3-1)}\times...\times&space;p_{sz}^{(a_{sz}-1)}" title="\inline m=p_1^{(a_1-1)}\times p_2^{(a_2-1)}\times p_3^{(a_3-1)}\times...\times p_{sz}^{(a_{sz}-1)}" /> 

而由于大质数的变化性会很大
我们可以考虑合并某两个因数  <img src="https://latex.codecogs.com/svg.image?\inline&space;a_i=a_i\times&space;a_j" title="\inline a_i=a_i\times&space;a_j" />   
例如如果给你  <img src="https://latex.codecogs.com/svg.image?\inline&space;n=16" title="\inline n=16" />   
我们可以分解成  <img src="https://latex.codecogs.com/svg.image?\inline&space;2*2*2*2" title="\inline 2*2*2*2" />  ，此时  <img src="https://latex.codecogs.com/svg.image?\inline&space;m=2^1*3^1*5^1*7^1=210" title="\inline m=2^1*3^1*5^1*7^1=210" />   
而考虑合并一下一个因数给第一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;2" title="\inline 2" /> ，此时  <img src="https://latex.codecogs.com/svg.image?\inline&space;m=2^3*3^1*5^1=120" title="\inline m=2^3*3^1*5^1=120" />   
会变得更小  

所以我们可以枚举我们可不可以在  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  的基础上乘上  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" />  ，也就是把  <img src="https://latex.codecogs.com/svg.image?\inline&space;a[j]" title="\inline a[j]" />  合并给  <img src="https://latex.codecogs.com/svg.image?\inline&space;a[i]" title="\inline a[i]" />  同时  <img src="https://latex.codecogs.com/svg.image?\inline&space;a[j]" title="\inline a[j]" />  删掉且整体  <img src="https://latex.codecogs.com/svg.image?\inline&space;sz--" title="\inline sz--" />   
看看这样做会不会更小更优
如果更优的话就和合并掉，然后继续进行这套操作  
  
数很大要开高精，这里直接拿  <img src="https://latex.codecogs.com/svg.image?\inline&space;BigInteger" title="\inline BigInteger" />  写了  
（由于计算了一下对  <img src="https://latex.codecogs.com/svg.image?\inline&space;n" title="\inline n" />  分解后本身就是  <img src="https://latex.codecogs.com/svg.image?\inline&space;log" title="\inline log" />  级别的，我们最多合并  <img src="https://latex.codecogs.com/svg.image?\inline&space;\frac{(logn+1)logn}2" title="\inline \frac{(logn + 1)logn}2" />  次，所以时间复杂度最高的为  <img src="https://latex.codecogs.com/svg.image?\inline&space;log(n)^2" title="\inline log(n)^2" /> ，然后  <img src="https://latex.codecogs.com/svg.image?\inline&space;Java" title="\inline Java" />  学的也不好，就啥都开暴力了（逃  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```java
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

public class Main {
        static int N = 100010;
        static Vector<BigInteger> prime = new Vector<BigInteger>();
        static Vector<Integer> intprime = new Vector<Integer>();
        static boolean[] notprime = new boolean[N];

        static BigInteger one = BigInteger.ONE;
        static BigInteger two = BigInteger.valueOf(2);
        static BigInteger zero = BigInteger.ZERO;
        static BigInteger ten = BigInteger.TEN;

        public static void Sieve () { // 线性筛
                notprime[0] = notprime[1] = true;
                for ( int i = 2; i < N; i ++ ) {
                        if ( !notprime[i] ) {
                                prime.add(BigInteger.valueOf(i));
                                intprime.add(i);
                        }
                        for ( int j = 0; j < intprime.size() && i * intprime.elementAt(j) < N; j ++ ) {
                                notprime[i * intprime.elementAt(j)] = true;
                                if ( i % intprime.elementAt(j) == 0 ) break;
                        }
                }
        }
        public static BigInteger ksm ( BigInteger a, BigInteger b ) { // 快速幂
                BigInteger res = BigInteger.ONE;
                while ( b.compareTo(zero) == 1 ) {
                        if ( b.mod(two).compareTo(one) == 0 ) res = res.multiply(a);
                        a = a.multiply(a);
                        b = b.divide(two);
                }
                return res;
        }
        public static void main ( String[] args ) {
                Scanner input = new Scanner(System.in);
                Sieve();
                BigInteger n = input.nextBigInteger();

                BigInteger[] dv = new BigInteger[100]; // 对n分解的质因数数组
                int sz = 0; // 数组长度
                for ( int i = 0; i < prime.size() && BigInteger.valueOf(i).multiply(BigInteger.valueOf(i)).compareTo(n) <= 0; i ++ ) {
                        while ( n.mod(prime.elementAt(i)).compareTo(zero) == 0 ) {
                                n = n.divide(prime.elementAt(i));
                                dv[sz ++] = prime.elementAt(i);
                        }
                }
                if ( n.compareTo(one) == 1 ) dv[sz ++] = n;

                for ( int i = 0; i < sz; i ++ ) { // 降序排个序（冒泡儿（逃
                        for ( int j = i + 1; j < sz; j ++ ) {
                                if ( dv[i].compareTo(dv[j]) == -1 ) {
                                        BigInteger tmp = dv[i];
                                        dv[i] = dv[j];
                                        dv[j] = tmp;
                                }
                        }
                }

                boolean flag = true;
                while ( flag ) {
                        flag = false; // false为这一趟没有a[j]可以给a[i]合并
                        BigInteger res = one;
                        for ( int i = 0; i < sz; i ++ ) { // 计算一下本身结果
                                res = res.multiply(ksm(prime.elementAt(i), dv[i].subtract(one)));
                        }
                        for ( int i = 0; i < sz; i ++ ) {
                                for ( int j = i + 1; j < sz; j ++ ) {
                                        dv[i] = dv[i].multiply(dv[j]); // a[j]乘给a[i]
                                        int idx = 0;
                                        BigInteger cur = one; // 计算这次剪掉a[j]后的结果
                                        for ( int k = 0; k < j; k ++ ) cur = cur.multiply(ksm(prime.elementAt(idx ++), dv[k].subtract(one)));
                                        for ( int k = j + 1; k < sz; k ++ ) cur = cur.multiply(ksm(prime.elementAt(idx ++), dv[k].subtract(one)));
                                        if ( cur.compareTo(res) == -1 )  { // 如果结果小于本身的，那就直接跳出循环开始找下一层
                                                flag = true;
                                                sz --; for ( int k = j; k < sz; k ++ ) dv[k] = dv[k + 1]; // 把 dv[j] 删掉 
                                                break;
                                        }
                                        dv[i] = dv[i].divide(dv[j]); // 否则的话就再把a[j]还回去
                                }
                                if ( flag ) {
                                        break;
                                }
                        }
                }

                BigInteger res = one; // 最终结果再算一下（复制粘贴上面的代码
                for ( int i = 0; i < sz; i ++ ) {
                        res = res.multiply(ksm(prime.elementAt(i), dv[i].subtract(one)));
                }
                System.out.println(res);
                input.close();
        }
}
```
