# 🔗
<a href="https://www.luogu.com.cn/problem/P3911"><img src="https://i.loli.net/2021/11/17/xhMKuwyIQiLC9dU.png"></a>

# 💡
先变一下柿子  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}&\sum\limits_{i=1}^n\sum\limits_{j=1}^nlcm(a_i,a_j)\\=&\sum\limits_{i=1}^n\sum\limits_{j=1}^na_ia_j\frac1{(a_i,a_j)}\\=&\sum\limits_{k=1}^{mx}\frac&space;1k\sum\limits_{i=1}^n\sum\limits_{j=1}^na_ia_j[(a_i,a_j)=k]\\=&\sum\limits_{k=1}^{mx}\frac&space;1kf(k)\end{aligned}" title="\inline \begin{aligned}&\sum\limits_{i=1}^n\sum\limits_{j=1}^nlcm(a_i,a_j)\\=&\sum\limits_{i=1}^n\sum\limits_{j=1}^na_ia_j\frac1{(a_i,a_j)}\\=&\sum\limits_{k=1}^{mx}\frac 1k\sum\limits_{i=1}^n\sum\limits_{j=1}^na_ia_j[(a_i,a_j)=k]\\=&\sum\limits_{k=1}^{mx}\frac 1kf(k)\end{aligned}" />   
接下来就是感性的莫反  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;F(k)=\sum\limits_{i=1}^n\sum\limits_{j=1}^na_ia_j[k|(a_i,a_j)]" title="\inline F(k)=\sum\limits_{i=1}^n\sum\limits_{j=1}^na_ia_j[k|(a_i,a_j)]" />   
可以发现这个  <img src="https://latex.codecogs.com/svg.image?\inline&space;F(k)" title="\inline F(k)" />  是可以通过埃氏筛预处理出来的  
那么就直接   
<img src="https://latex.codecogs.com/svg.image?\inline&space;f(k)=\sum\limits_{d=1}^{\frac&space;Nk}\mu(d)F(dk)" title="\inline f(k)=\sum\limits_{d=1}^{\frac Nk}\mu(d)F(dk)" />   
则原柿就是  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\sum\limits_{k=1}^N\frac 1k\sum\limits_{d=1}^{\frac Nk}\mu(d)F(dk)" title="\inline =\sum\limits_{k=1}^N\frac 1k\sum\limits_{d=1}^{\frac Nk}\mu(d)F(dk)" />   
  
发现线性增长的  <img src="https://latex.codecogs.com/svg.image?\inline&space;k" title="\inline k" />  对应的  <img src="https://latex.codecogs.com/svg.image?\inline&space;T" title="\inline T" />  的范围递减得很快  
所以直接暴力就行了  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N =  1e5 + 10;
int a[N], n;
ll F[N];

namespace Number {
        int mu[N];
        bool not_prime[N];
        vector<int> prime;
        inline void Sieve () {
                not_prime[0] = not_prime[1] = mu[1] = 1;
                for ( int i = 2; i < N; i ++ ) {
                        if ( !not_prime[i] ) 
                                prime.push_back(i),
                                mu[i] = -1;
                        for ( int j = 0; j < prime.size() && i * prime[j] < N; j ++ ) {
                                not_prime[i * prime[j]] = true;
                                if ( i % prime[j] == 0 ) break; 
                                mu[i * prime[j]] = -mu[i];
                        }
                }
        }

        ll mark[N];
        inline void Pre () {
                for ( int i = 0; i < n; i ++ ) mark[a[i]] += a[i];
                for ( int d = 1; d < N; d ++ ) {
                        for ( int i = d; i < N; i += d ) {
                                F[d] += mark[i];
                        }
                        F[d] *= F[d];
                }
        }
} using namespace Number;

int main () {
        cin >> n; for ( int i = 0; i < n; i ++ ) cin >> a[i];
        Pre (); Sieve ();
        ll res = 0;
        for ( int k = 1; k < N; k ++ ) {
                ll cur = 0;
                for ( int d = 1; d < N / k; d ++ ) cur += mu[d] * F[d * k];
                res += cur / k;
        }
        cout << res << endl;
}
```
