# 🔗
<a href="https://www.luogu.com.cn/problem/P2568"><img src="https://img-blog.csdnimg.cn/53942c61c3b14914bd7b5edc3762772c.png"></a>

# 💡
<img src="https://latex.codecogs.com/svg.image?\begin{aligned}&\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)\in\{prime\}]\\=&\sum\limits_{p\in&space;\{prime\}}^{\le&space;n}\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)=p]\\=&\sum\limits_{p\in\{prime\}}^{\le&space;n}\sum\limits_{i=1}^{\left\lfloor\frac&space;np\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac&space;np\right\rfloor}[gcd(i,j)=1]\end{aligned}" title="\begin{aligned}&\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)\in\{prime\}]\\=&\sum\limits_{p\in \{prime\}}^{\le n}\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)=p]\\=&\sum\limits_{p\in\{prime\}}^{\le n}\sum\limits_{i=1}^{\left\lfloor\frac np\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac np\right\rfloor}[gcd(i,j)=1]\end{aligned}" />  
对于<img src="https://latex.codecogs.com/svg.image?\sum\limits_{i=1}^{\left\lfloor\frac&space;np\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac&space;np\right\rfloor}[gcd(i,j)=1]" title="\sum\limits_{i=1}^{\left\lfloor\frac np\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac np\right\rfloor}[gcd(i,j)=1]" />  
我们可以使用莫反变成<img src="https://latex.codecogs.com/svg.image?\mu(d)\left\lfloor\frac&space;nd\right\rfloor^2" title="\mu(d)\left\lfloor\frac nd\right\rfloor^2" />    
<a href="https://github.com/Chivas-Regal/ACM/blob/main/Code/%E6%95%B0%E5%AD%A6/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/%E4%BB%AA%E4%BB%97%E9%98%9F.md">（具体操作请看这里）</a>
那么就是让求  
<img src="https://latex.codecogs.com/svg.image?\sum\limits_{p\in\{prime\}}^{\le&space;n}\sum\limits_{d=1}^{\left\lfloor\frac&space;np\right\rfloor}\mu(d)\left\lfloor\frac&space;nd\right\rfloor^2" title="\sum\limits_{p\in\{prime\}}^{\le n}\sum\limits_{d=1}^{\left\lfloor\frac np\right\rfloor}\mu(d)\left\lfloor\frac nd\right\rfloor^2" />  
素数表直接用莫比乌斯函数打表得到的即可  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
namespace Number {
        const ll N = 1e7 + 10;
        bool notprime[N];
        ll mu[N];
        vector<ll> prime;
        ll sum[N];

        inline void Sieve () {
                notprime[1] = notprime[0] = mu[1] = 1;
                for ( ll i = 2; i < N; i ++ ) {
                        if ( !notprime[i] ) 
                                prime.push_back(i),
                                mu[i] = -1;
                        for ( ll j = 0; j < prime.size() && i * prime[j] < N; j ++ ) {
                                notprime[i * prime[j]] = 1;
                                if ( i % prime[j] == 0 ) continue;
                                mu[i * prime[j]] = -mu[i];
                        }
                }
                for ( ll i = 1; i < N; i ++ ) sum[i] = sum[i - 1] + mu[i];
        }

        inline ll g ( ll k, ll x ) { return k / (k / x); }

        map<ll, ll> S;
        inline ll SUM ( ll x ) {
                if ( x < N ) return sum[x];
                if ( S[x] ) return S[x];
                ll res = 1;
                for ( ll L = 2, R; L <= x; L = R + 1 ) {
                        R = min ( x, g(x, L) );
                        res -= (R - L + 1) * SUM(x / L);
                } return S[x] = res;
        }
} using namespace Number;

inline ll Solve ( ll n, ll k ) {
        n /= k;
        ll res = 0;
        for ( ll l = 1, r; l <= n; l = r + 1 ) {
                r = g(n, l);
                res += (SUM(r) - SUM(l - 1)) * (n / l) * (n / l);
        }
        return res;
}

int main () {
        ios::sync_with_stdio(false); Sieve ();
        int n; cin >> n;
        ll res = 0;
        for ( int i = 0; i < prime.size() && prime[i] <= n; i ++ ) res += Solve (n, prime[i]);
        cout << res << endl;
}
```
