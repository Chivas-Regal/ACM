# 🔗
<a href="https://www.luogu.com.cn/problem/P1390"><img src="https://img-blog.csdnimg.cn/f8b3a5c1702d452782bef71a82097d2b.png"></a>

# 💡

看见 <img src="https://math.azureedge.net/$$/gcd"/> 首先把式子变成我们常用的莫反套路  
<img src="https://latex.codecogs.com/svg.image?\begin{aligned}&space;&space;&space;&space;&space;&space;&space;&space;&\sum\limits_{i=1}^n\sum\limits_{j=i&plus;1}^ngcd(i,j)\\&space;&space;&space;&space;&space;&space;&space;=&\sum\limits_{k=1}^n\sum\limits_{i=1}^n\sum\limits_{j=i&plus;1}^n[gcd(i,j)=k]*k\\&space;&space;&space;&space;&space;&space;&space;&space;=&\sum\limits_{k=1}^nk\frac&space;{\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)=k]-1}2\\&space;&space;&space;&space;&space;&space;&space;&space;=&\sum\limits_{k=1}^nk\frac&space;{\sum\limits_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{n}{k}\right\rfloor}[gcd(i,j)=1]-1}2&space;&space;&space;&space;&space;&space;&space;&space;\end{aligned}" title="\begin{aligned} &\sum\limits_{i=1}^n\sum\limits_{j=i+1}^ngcd(i,j)\\ =&\sum\limits_{k=1}^n\sum\limits_{i=1}^n\sum\limits_{j=i+1}^n[gcd(i,j)=k]*k\\ =&\sum\limits_{k=1}^nk\frac {\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)=k]-1}2\\ =&\sum\limits_{k=1}^nk\frac {\sum\limits_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{n}{k}\right\rfloor}[gcd(i,j)=1]-1}2 \end{aligned}" />  
减 <img src="https://math.azureedge.net/$$/1"> 是为了减去 <img src="https://math.azureedge.net/$$/i=j=k"> 的情况，除 <img src="https://math.azureedge.net/$$/2"> 是为了消除重复枚举一对的情况  
  
那么对于里面的  
<img src="https://math.azureedge.net/$$/\sum\limits_{i=1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{n}{k}\right\rfloor}[gcd(i,j)=1]">  
我们让  
<img src="https://math.azureedge.net/$$/n'=\left\lfloor\frac{n}{k}\right\rfloor">  
可以感性地利用莫比乌斯反演化简为  
<img src="https://math.azureedge.net/$$/\sum\limits_{d=1}^{n'}\mu(d)\left \lfloor \frac {n'}d \right \rfloor \left \lfloor \frac {n'}d \right \rfloor">  
<a href="https://github.com/Chivas-Regal/ACM/blob/main/Code/%E6%95%B0%E5%AD%A6/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/%E4%BB%AA%E4%BB%97%E9%98%9F.md">(具体操作看这里)</a>  

由于 <img src="https://math.azureedge.net/$$/n'k=n"> 是一个曲线函数，则总时间复杂度不会太高  
我们对上面化简后的式子写成一个方程 <img src="https://math.azureedge.net/$$/Solve()">   
则   
<img src="https://math.azureedge.net/$$/res = \sum\limits_{k=1}^nk\frac{Solve()-1}{2}">  
<img src="https://math.azureedge.net/$$/Solve()"> 里面随便杜教筛一下随便数论分块一下  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const ll N = 2e6 + 10;
namespace Number {
        ll mu[N], sum[N];
        bool notprime[N];
        vector<ll> prime;
        inline void Sieve () {
                mu[1] = notprime[1] = notprime[0] = 1;
                for ( ll i = 2; i < N; i ++ ) {
                        if ( !notprime[i] ) 
                                prime.push_back(i),
                                mu[i] = -1;
                        for ( ll j = 0; j < prime.size() && i * prime[j] < N; j ++ ) {
                                notprime[i * prime[j]] = 1;
                                if ( i % prime[j] == 0 ) break;
                                mu[i * prime[j]] = -mu[i];
                        }
                }
                for ( ll i = 1; i < N; i ++ ) sum[i] = sum[i - 1] + mu[i]; 
        }
        inline ll g ( ll k, ll x ) { return k / (k / x); }

        map<ll, ll> S;
        inline ll SUM ( ll x ) {
                if ( x < N ) return sum[x];
                if ( S[x] ) return S[x];
                ll res = 1;
                for ( ll L = 2, R; L <= x; L = R + 1 ) {
                        R = min ( x, g(x, L) );
                        res -= (R - L + 1) * SUM(x / L);
                } return S[x] = res;
        }
} using namespace Number;

inline ll Solve ( ll n, ll k ) {
        ll res = 0; n /= k;
        for ( ll l = 1, r; l <= n; l = r + 1 ) {
                r = min(n, g(n, l));
                res += (SUM(r) - SUM(l - 1)) * (n / l) * (n / l);
        }
        return res;
}

int main () {
        ios::sync_with_stdio(false); Sieve ();
        ll n; cin >> n;
        ll res = 0;
        for ( ll k = 1; k <= n; k ++ ) {
                res += k * (Solve(n, k) - 1) / 2;
        }
        cout << res << endl;
}
```
