 # 🔗
 <a href="https://www.luogu.com.cn/problem/P3768"><img src="https://i.loli.net/2021/11/16/zA7s3d9DSEl8eVx.png"></a>
 
 # 💡
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}main(n)=&\sum\limits_{i=1}^n\sum\limits_{j=1}^nij(i,j)\\=&\sum\limits_{k=1}^nk\sum\limits_{i=1}^ni\sum\limits_{j=1}^nj[(i,j)=k]\\=&\sum\limits_{k=1}^nk{\color{red}f(k)}\end{aligned}" title="\inline \begin{aligned}main(n)=&\sum\limits_{i=1}^n\sum\limits_{j=1}^nij(i,j)\\=&\sum\limits_{k=1}^nk\sum\limits_{i=1}^ni\sum\limits_{j=1}^nj[(i,j)=k]\\=&\sum\limits_{k=1}^nk{\color{red}f(k)}\end{aligned}" />     
  
**莫比乌斯反演**一下  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;f(k)=\sum\limits_{i=1}^n\sum\limits_{j=1}^n[(i,j)=k]" title="\inline f(k)=\sum\limits_{i=1}^n\sum\limits_{j=1}^n[(i,j)=k]" /> 
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}F(k)=&\sum\limits_{i=1}^n\sum\limits_{j=1}^n[k\mid(i,j)]\\=&\sum\limits_{i=1}^{\frac&space;nk}ik\sum\limits_{j=1}^{\frac&space;nk}jk\\=&k^2(\frac{(1+\frac&space;nk)\frac&space;nk}2)^2\end{aligned}" title="\inline \begin{aligned}F(k)=&\sum\limits_{i=1}^n\sum\limits_{j=1}^n[k\mid(i,j)]\\=&\sum\limits_{i=1}^{\frac nk}ik\sum\limits_{j=1}^{\frac nk}jk\\=&k^2(\frac{(1+\frac nk)\frac nk}2)^2\end{aligned}" />   
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}\therefore&space;f(k)=&\sum\limits_{d=1}^n\mu(\frac&space;dk)F(d)\\=&\sum\limits_{d=1}^{\frac&space;nk}\mu(d)F(dk)\\=&\sum\limits_{d=1}^{\frac&space;nk}\mu(d)(dk)^2(\frac{(1+\frac&space;n{dk})\frac&space;n{dk}}2)^2\\=&\sum\limits_{d=1}^{\frac&space;nk}\mu(d)(dk)^2{\color{red}sum(\frac&space;n{dk})}^2\end{aligned}" title="\inline \begin{aligned}\therefore f(k)=&\sum\limits_{d=1}^n\mu(\frac dk)F(d)\\=&\sum\limits_{d=1}^{\frac nk}\mu(d)F(dk)\\=&\sum\limits_{d=1}^{\frac nk}\mu(d)(dk)^2(\frac{(1+\frac n{dk})\frac n{dk}}2)^2\\=&\sum\limits_{d=1}^{\frac nk}\mu(d)(dk)^2{\color{red}sum(\frac n{dk})}^2\end{aligned}" />    
 <img src="https://latex.codecogs.com/svg.image?\inline&space;main(n)=\sum\limits_{k=1}^nk\sum\limits_{d=1}^{\frac&space;nk}\mu(d)(dk)^2sum(\frac&space;n{dk})^2" title="\inline main(n)=\sum\limits_{k=1}^nk\sum\limits_{d=1}^{\frac nk}\mu(d)(dk)^2sum(\frac n{dk})^2" />   
令  <img src="https://latex.codecogs.com/svg.image?\inline&space;T=dk" title="\inline T=dk" />   
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}main(n)=&\sum\limits_{k=1}^nk\sum\limits_{\frac&space;Tk=1}^{\frac&space;nk}\mu(\frac&space;Tk)T^2sum(\frac&space;nT)^2\\=&\sum\limits_{T=1}^nT^2sum(\frac&space;nT)\sum\limits_{k|T}k\mu(\frac&space;Tk)\end{aligned}" title="\inline \begin{aligned}main(n)=&\sum\limits_{k=1}^nk\sum\limits_{\frac Tk=1}^{\frac nk}\mu(\frac Tk)T^2sum(\frac nT)^2\\=&\sum\limits_{T=1}^nT^2sum(\frac nT)\sum\limits_{k|T}k\mu(\frac Tk)\end{aligned}" />    
  
对于  <img src="https://latex.codecogs.com/svg.image?\inline&space;\sum\limits_{k|T}k\mu(\frac Tk)" title="\inline \sum\limits_{k|T}k\mu(\frac Tk)" />  这部分，我们可以**欧拉反演**  
根据欧拉反演的小结论  <img src="https://latex.codecogs.com/svg.image?\inline&space;\sum\limits_{k|T}\frac{\mu(k)}k=\frac&space;{\phi(T)}T" title="\inline \sum\limits_{k|T}\frac{\mu(k)}k=\frac {\phi(T)}T" />   
我们这里可以这样变化  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}&\sum\limits_{k|T}k\mu(\frac&space;Tk)\\=&\sum\limits_{k|T}k\frac{\mu(\frac&space;Tk)}{\frac&space;Tk}\frac&space;Tk\end{aligned}" title="\inline \begin{aligned}&\sum\limits_{k|T}k\mu(\frac Tk)\\=&\sum\limits_{k|T}k\frac{\mu(\frac Tk)}{\frac Tk}\frac Tk\end{aligned}" />   
由于  <img src="https://latex.codecogs.com/svg.image?\inline&space;k" title="\inline k" />  与 $\frac Tk$ 一一对应，所以  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;=\sum\limits_{k|T}T\frac{\mu(k)}k=\phi(T)" title="\inline =\sum\limits_{k|T}T\frac{\mu(k)}k=\phi(T)" />   
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\therefore&space;main(n)=\sum\limits_{T=1}^nT^2sum(\frac&space;nT)\phi(T)" title="\inline \therefore main(n)=\sum\limits_{T=1}^nT^2sum(\frac nT)\phi(T)" />   
  
注意到  <img src="https://latex.codecogs.com/svg.image?\inline&space;T^2" title="\inline T^2" />  不可数论分块相等  
所以我们考虑与  <img src="https://latex.codecogs.com/svg.image?\inline&space;\phi(T)" title="\inline \phi(T)" />  放在一起进行杜教筛

 
 # <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
 ```cpp
 ll n, mod, res;

namespace Number {
        const int N = 1e7;
        ll phi[N], sum[N];
        bool not_prime[N];
        vector<int> prime;
        
        inline void Sieve () {
                not_prime[1] = not_prime[0] = phi[1] = 1;
                for ( int i = 2; i < N; i ++ ) {
                        if ( !not_prime[i] ) 
                                prime.push_back(i),
                                phi[i] = i - 1;
                        for ( int j = 0; j < prime.size() && (ll)i * prime[j] < N; j ++ ) {
                                not_prime[i * prime[j]] = 1;
                                if ( i % prime[j] == 0 ) { 
                                        phi[i * prime[j]] = phi[i] * prime[j];
                                        break;
                                } else phi[i * prime[j]] = phi[i] * ( prime[j] - 1 );
                        }
                }
                for ( ll i = 1; i < N; i ++ ) sum[i] = (sum[i - 1] + i * i % mod * phi[i] % mod) % mod;
        }

        inline ll g( ll k, ll x ) { return k / (k / x); }
        inline ll ksm ( ll a, ll b ) { ll res = 1; while ( b ) { if ( b & 1 ) res = res * a % mod; a = a * a % mod; b >>= 1; } return res; }
        inline ll inv ( ll x ) { return ksm(x, mod - 2); }
        ll inv2; inline ll sigma_1_to_n ( ll n ) { n %= mod; return n * (n + 1) % mod * inv2 % mod; }
        ll inv6; inline ll sigma_1mi_to_nmi ( ll n ) { n %= mod; return n * (n + 1) % mod * (n + n + 1) % mod * inv6 % mod; }

        map<ll, ll> S;
        inline ll SUM ( ll x ) {
                if(x < N) return sum[x];
                if(S[x]) return S[x];
                ll res = sigma_1_to_n(x) * sigma_1_to_n(x) % mod;
                for(ll L = 2, R; L <= x; L = R + 1){
                        R = min(x, g(x, L));
                        res = (res - (sigma_1mi_to_nmi(R) - sigma_1mi_to_nmi(L - 1) + mod) % mod * SUM(x / L) % mod + mod) % mod;
                }return S[x] = res;
        }
} using namespace Number;


int main () {
        cin >> mod >> n; 
        Sieve (); inv2 = inv(2); inv6 = inv(6);
        for ( ll l = 1, r; l <= n; l = r + 1 ) {
                r = g(n, l);
                ll add = (SUM(r) - SUM(l - 1) + mod) % mod * sigma_1_to_n( n / l ) % mod * sigma_1_to_n( n / l ) % mod;
                res = (res + add) % mod;
        }
        cout << res << endl;
}
 ```
 
