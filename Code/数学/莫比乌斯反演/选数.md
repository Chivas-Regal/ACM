# 🔗
https://www.luogu.com.cn/problem/P3172

# 💡
题目让求  
<img src="https://latex.codecogs.com/svg.image?\sum\limits_{i_1=L}^H\sum\limits_{i_2=L}^H....\sum\limits_{i_n=L}^H[gcd=k]" title="\sum\limits_{i_1=L}^H\sum\limits_{i_2=L}^H....\sum\limits_{i_n=L}^H[gcd=k]" />
  
所以我们令:  
<img src="https://latex.codecogs.com/svg.image?f(k)=\sum\limits_{i_1=L}^H\sum\limits_{i_2=L}^H....\sum\limits_{i_n=L}^H[gcd=k]" title="f(k)=\sum\limits_{i_1=L}^H\sum\limits_{i_2=L}^H....\sum\limits_{i_n=L}^H[gcd=k]" />

为满足:  
<img src="https://latex.codecogs.com/svg.image?F(k)=\sum\limits_{\frac&space;kd}f(d)" title="F(k)=\sum\limits_{\frac kd}f(d)" />

令：  
<img src="https://latex.codecogs.com/svg.image?F(k)&space;=&space;\sum\limits_{i_1=L}^H\sum\limits_{i_2=L}^H....\sum\limits_{i_n=L}^H[k|gcd]" title="F(k) = \sum\limits_{i_1=L}^H\sum\limits_{i_2=L}^H....\sum\limits_{i_n=L}^H[k|gcd]" />

为了使每个i都是k的倍数保证每次枚举都是可以使得<img src="https://latex.codecogs.com/svg.image?[k|gcd]=1" title="[k|gcd]=1" />  
我们设<img src="https://latex.codecogs.com/svg.image?i'=\frac&space;ik" title="i'=\frac ik" />，枚举<img src="https://latex.codecogs.com/svg.image?i'" title="i'" />，也就是k的倍数  
得到：  
<img src="https://latex.codecogs.com/svg.image?F(k)&space;=&space;\sum\limits_{i_1'=\frac{L-1}{k}}^\frac&space;Hk\sum\limits_{i_2'=\frac{L-1}{k}}^\frac&space;Hk....\sum\limits_{i_n'=\frac{L-1}{k}}^\frac&space;Hk1" title="F(k) = \sum\limits_{i_1'=\frac{L-1}{k}}^\frac Hk\sum\limits_{i_2'=\frac{L-1}{k}}^\frac Hk....\sum\limits_{i_n'=\frac{L-1}{k}}^\frac Hk1" />  
  
可以化简为：  
<img src="https://latex.codecogs.com/svg.image?F(k)=(\left&space;\lfloor&space;\frac{H}{k}&space;\right&space;\rfloor&space;-&space;\left&space;\lfloor&space;\frac{L-1}{k}&space;\right&space;\rfloor&space;&space;)^n" title="F(k)=(\left \lfloor \frac{H}{k} \right \rfloor - \left \lfloor \frac{L-1}{k} \right \rfloor )^n" />  
  
由莫反定理得：  
<img src="https://latex.codecogs.com/svg.image?f(k)=\sum\limits_{k|d}\mu(\frac&space;dk)F(d)" title="f(k)=\sum\limits_{k|d}\mu(\frac dk)F(d)" />  
为了使枚举到的d均为k的倍数  
我们设<img src="https://latex.codecogs.com/svg.image?d'&space;=&space;\frac&space;dk\quad&space;H'=\frac&space;Hk" title="d' = \frac dk\quad H'=\frac Hk" />，此时<img src="https://latex.codecogs.com/svg.image?d=d'k" title="d=d'k" />  
  
则：  
<img src="https://latex.codecogs.com/svg.image?f(k)=\sum\limits_{d'=1}^{H'}\mu(d')F(d'k)" title="f(k)=\sum\limits_{d'=1}^{H'}\mu(d')F(d'k)" />  
  
此时<img src="https://latex.codecogs.com/svg.image?F(d'k)=(\left&space;\lfloor&space;\frac{H}{d'k}&space;\right&space;\rfloor&space;-&space;\left&space;\lfloor&space;\frac{L-1}{d'k}&space;\right&space;\rfloor&space;&space;)^n" title="F(d'k)=(\left \lfloor \frac{H}{d'k} \right \rfloor - \left \lfloor \frac{L-1}{d'k} \right \rfloor )^n" />  
  
所以：  
<img src="https://latex.codecogs.com/svg.image?f(k)=\sum_{d'=1}^{H'}\mu(d')(\left&space;\lfloor&space;\frac{H'}{d'}&space;\right&space;\rfloor&space;-&space;\left&space;\lfloor&space;\frac{L'}{d'}&space;\right&space;\rfloor&space;&space;)^n" title="f(k)=\sum_{d'=1}^{H'}\mu(d')(\left \lfloor \frac{H'}{d'} \right \rfloor - \left \lfloor \frac{L'}{d'} \right \rfloor )^n" />  
  
因为<img src="https://latex.codecogs.com/svg.image?H'" title="H'" />可能会很大，所以我们整除分块  
同时需要前缀和  
这里用杜教筛计算前缀和即可  


# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <vector>
#include <map>
#define ll long long

using namespace std;

const ll maxn = 2e6 + 10;//杜教筛的安全maxn
const ll mod = 1e9 + 7;

ll mu[maxn];//Mobius函数表
vector<ll> prime;
ll isprime[maxn];
ll sum[maxn];//mu的前缀和

inline void Mobius(){//线性筛
        mu[1] = 1;//特判mu[i] = 1
        isprime[0] = isprime[1] = 1;
        for ( ll i = 2; i < maxn; i ++ ) {
                if ( !isprime[i] ) mu[i] = -1, prime.push_back(i);//质数的质因子只有自己，所以为-1
                for ( ll j = 0; j < prime.size() && i * prime[j] < maxn; j ++ ) {
                        isprime[i * prime[j]] = 1;
                        if ( i % prime[j] == 0 ) break;
                        mu[i * prime[j]] = - mu[i];//积性函数性质： (i * prime[j])多出来一个质数因数(prime[j])，修正为 (-1) * mu[i]
                }
        }
        //剩余的没筛到的是其他情况，为0
        for ( ll i = 1; i < maxn; i ++ ) sum[i] = sum[i - 1] + mu[i];//记录前缀和，为了整除分块
}

map<ll, ll> S;//杜教筛处理出的前缀和

inline ll g ( ll k, ll x ) { return k / (k / x); }//整除分块的r值

inline ll SUM ( ll x ) {//杜教筛
        if ( x < maxn ) return sum[x];
        if ( S[x]) return S[x];
        ll res = 1;
        for ( ll L = 2, R; L <= x; L = R + 1 ) {
                R = min ( x, g ( x, L ) );
                res = ( res - (R - L + 1) * SUM(x / L) % mod + mod ) % mod;//模数相减会出负数，所以加上一个mod
        }return S[x] = res;
}

inline ll ksm ( ll a, ll b ) {//计算那个n次方
        ll res = 1;
        while ( b ) {
                if ( b & 1 ) res = res * a % mod;
                a = a * a % mod;
                b >>= 1;
        } return res;
}

int main () { Mobius();
        ll n, k, L, H; cin >> n >> k >> L >> H; L = (L - 1) / k, H /= k;//L直接处理为L'，H直接处理为H'
        ll res = 0;
        for ( ll l = 1, r; l <= H; l = r + 1 ) {

                if ( L / l) r = min(g(L, l), g(H, l));//防止出现除0的情况
                else r =  g ( H, l );

                res = ( res + ( SUM ( r ) - SUM ( l - 1 ) + mod ) * ksm ( H / l - L / l, n ) % mod ) % mod;//公式，但模数相减会出负数，所以加上一个mod
        } cout << res << endl;
}
```
