# 🔗
<a href="https://www.luogu.com.cn/problem/P3704"><img src="https://i.loli.net/2021/10/29/6Y3v9ZCJsmfwch5.png"></a>

# 💡
<img src="https://latex.codecogs.com/svg.image?\begin{aligned}&main(n,m)\\=&\prod\limits_{i=1}^n\prod\limits_{j=1}^mf_{(i,j)}\\=&\prod_{k=1}^{mn}f_k^{\sum\limits_{i=1}^n\sum\limits_{j=1}^m[(i,j)=k]}\\=&\prod\limits_{k=1}^{mn}f_k^{\sum\limits_{d=1}^{\left\lfloor\frac&space;{mn}k\right\rfloor}\mu(d)\left\lfloor\frac&space;{n}{dk}\right\rfloor\left\lfloor\frac&space;{m}{dk}\right\rfloor}\end{aligned}" title="\begin{aligned}&main(n,m)\\=&\prod\limits_{i=1}^n\prod\limits_{j=1}^mf_{(i,j)}\\=&\prod_{k=1}^{mn}f_k^{\sum\limits_{i=1}^n\sum\limits_{j=1}^m[(i,j)=k]}\\=&\prod\limits_{k=1}^{mn}f_k^{\sum\limits_{d=1}^{\left\lfloor\frac {mn}k\right\rfloor}\mu(d)\left\lfloor\frac {n}{dk}\right\rfloor\left\lfloor\frac {m}{dk}\right\rfloor}\end{aligned}" />  
  
两个变量换成一个 <img src="https://latex.codecogs.com/svg.image?T=dk,\;k=\frac&space;Td,\;d=\frac&space;Tk" title="T=dk,\;k=\frac Td,\;d=\frac Tk" />  
  
<img src="https://latex.codecogs.com/svg.image?=\prod\limits_{k=1}^{mn}f_k^{\sum\limits_{\frac&space;Tk=1}^{mn}\mu(\frac&space;Tk)\left\lfloor\frac&space;mT\right\rfloor\left\lfloor\frac&space;nT\right\rfloor}" title="=\prod\limits_{k=1}^{mn}f_k^{\sum\limits_{\frac Tk=1}^{mn}\mu(\frac Tk)\left\lfloor\frac mT\right\rfloor\left\lfloor\frac nT\right\rfloor}" />  
  
指数可以看做 <img src="https://latex.codecogs.com/svg.image?T" title="T" /> 枚举 <img src="https://latex.codecogs.com/svg.image?k" title="k" /> 倍数  
  
<img src="https://latex.codecogs.com/svg.image?=\prod\limits_{T=1}^{mn}\prod\limits_{k\mid&space;T}f_k^{\mu(\frac&space;Tk)\left\lfloor\frac&space;mT\right\rfloor\left\lfloor\frac&space;nT\right\rfloor}" title="=\prod\limits_{T=1}^{mn}\prod\limits_{k\mid T}f_k^{\mu(\frac Tk)\left\lfloor\frac mT\right\rfloor\left\lfloor\frac nT\right\rfloor}" />  
  
令 <img src="https://latex.codecogs.com/svg.image?g(T)=\prod\limits_{k\mid&space;T}f_k^{\mu(\frac&space;Tk)}" title="g(T)=\prod\limits_{k\mid T}f_k^{\mu(\frac Tk)}" />  
  
<img src="https://latex.codecogs.com/svg.image?=\prod\limits_{T=1}^{mn}g(T)^{\left\lfloor\frac&space;mT\right\rfloor\left\lfloor\frac&space;nT\right\rfloor}" title="=\prod\limits_{T=1}^{mn}g(T)^{\left\lfloor\frac mT\right\rfloor\left\lfloor\frac nT\right\rfloor}" />  
  
<img src="https://latex.codecogs.com/svg.image?g(T)" title="g(T)" /> 可以预处理，外层数论分块  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
namespace Number {
        const ll N = 1e6 + 10;
        const ll mod = 1e9 + 7;
        ll mu[N], sum[N], g[N], f[N];
        bool notprime[N];
        vector<ll> prime;
        inline ll ksm ( ll a, ll b ) {
                ll res = 1;
                while ( b ) {
                        if ( b & 1 ) res = res * a % mod;
                        a = a * a % mod;
                        b >>= 1;
                }
                return res;
        }
        inline void Sieve () {
                notprime[0] = notprime[1] = mu[1] = f[1] = g[0] = g[1] = 1; f[0] = 0;
                for ( ll i = 2; i < N; i ++ ) {
                        f[i] = (f[i - 1] + f[i - 2]) % mod, g[i] = 1;
                        if ( !notprime[i] ) 
                                prime.push_back(i),
                                mu[i] = -1;
                        for ( ll j = 0; j < prime.size() && prime[j] * i < N; j ++ ) {
                                notprime[i * prime[j]] = 1;
                                if ( i % prime[j] == 0 ) break;
                                mu[i * prime[j]] = -mu[i];
                        }
                }
        }
        inline ll Inv ( ll x ) { return ksm(x, mod - 2); }
        inline ll Get ( ll n, ll k ) { return n / (n / k); }
        inline void Pre () {
                for ( ll i = 0; i < N; i ++ ) sum[i] = (sum[i - 1] + mu[i]) % mod;
                for ( ll k = 1; k < N; k ++ ) {
                        for ( ll T = k; T < N; T += k ) {
                                if ( mu[T / k] == 1 )        g[T] = g[T] * f[k] % mod; 
                                else if ( mu[T / k] == -1 )  g[T] = g[T] * Inv(f[k]) % mod;
                        }
                }
                for ( ll i = 1; i < N; i ++ ) g[i] = g[i - 1] * g[i] % mod;
        }
} using namespace Number;

inline void Solve () {
        ll n, m; cin >> n >> m; ll mn = min ( m, n );
        ll res = 1;
        for ( ll l = 1, r; l <= mn; l = r + 1 ) {
                r = min ( Get(n, l), Get(m, l) );
                res = res * ksm( g[r] * Inv(g[l - 1]) % mod, (m / l) * (n / l) % (mod - 1) ) % mod;
        }
        cout << res << endl;
}

int main () {
        ios::sync_with_stdio(false); Sieve (); Pre ();
        ll cass; cin >> cass; while ( cass -- ) Solve ();
}
```
