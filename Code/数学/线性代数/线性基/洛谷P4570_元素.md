# 🔗
https://darkbzoj.tk/problem/2460

# 💡
本题让求id异或不为0的情况下，val的最大值  
众所周知，一个数如果与前面出现过的数异或值相等，那带上它的异或值为0  
同时线性基中，判断是否会与前面的异或值相等，可以用线性基中“在穿过线性基，若最后被消完，说明带上它会与前面的凑0异或”的性质  
所以每次插入加判断是否为0    

由于前面的先放进去线性基为空，不容易被清0，所以我们利用贪心将val较大的id放前面，然后一个个特判即可  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N = 1100;
const int MaxBit = 60;

struct Ore { ll id, val; friend bool operator < ( Ore a, Ore b ) { return a.val > b.val; }}a[N]; // 按价值升序排序
ll n, d[70], res;

inline void Insert ( Ore A ) {
        ll x = A.id;
        for ( ll i = MaxBit; i >= 0; i -- ) {
                if ( (x >> i) & 1 ) {
                        if ( d[i] ) x ^= d[i];
                        else { d[i] = x; break; }
                }
        }
        if ( x ) res += A.val; // 若没有与前面的异或为0，就加入res
}

int main (){
        n = inputLL();
        for ( ll i = 0; i < n; i ++ ) a[i] = {inputLL(), inputLL()};
        sort ( a, a + n );
        for ( ll i = 0; i < n; i ++ ) Insert( a[i] );
        outLL(res);
        return 0;
};
```


