# 🔗
<a href="https://www.luogu.com.cn/problem/P4301"><img src="https://img-blog.csdnimg.cn/75ce3df45add404b9abf8896e23635ec.png"></a>

# 💡
根据尼姆博弈异或sg  
我们知道如果这些数如果异或出来0的话就不行  
所以作为第一个人拿的时候要选择性拿走  
  
一个一个插入线性基，如果有一个插不进去代表这个插进去的话就可以和已有的形成0  
我们就需要拿走这个数  
我们要从大往小插入，这样可以尽可能让大的进入线性基从而缩小答案  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const ll mxbt = 30;
const ll N = 1e3 + 10;

namespace XORstruct {
        ll d[mxbt + 10];
        inline bool Insert ( ll x ) {
                for ( ll i = mxbt; i >= 0; i -- ) {
                        if ( x & (1ll << i) ) {
                                if ( !d[i] ) {d[i] = x; return true;}
                                else         x ^= d[i];
                        }
                }
                return false;
        }
} using namespace XORstruct;

int main () {
        ll n, res = 0; cin >> n;
        ll a[n + 10]; for ( int i = 0; i < n; i ++ ) cin >> a[i];
        sort ( a, a + n, greater<ll>() );
        for ( ll i = 0; i < n; i ++ ) {
                if ( !Insert ( a[i] ) ) res += a[i];
        }
        cout << res << endl;
}
```
