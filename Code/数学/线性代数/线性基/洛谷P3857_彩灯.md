# 🔗
<a href="https://www.luogu.com.cn/problem/P3857"><img src="https://img-blog.csdnimg.cn/0c0677a36be64b2f81e96ef67f7c40ee.png"></a>

# 💡
这样的彩灯可以看作一个二进制数列  
数列异或不同的个数就是这个二进制数列能利用线性基异或出来的个数  
那么我们构造出线性基，化简后统计一下不同的数量即可，最后有 2^cnt 的个数

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int mxBit = 50;
const int mod = 2008;
ll d[mxBit + 10];
ll l[mxBit + 10];
int cnt, n, m;

inline void Insert ( ll x ) {
        for ( int i = mxBit; i >= 0; i -- ) {
                if ( x & (1ll << i) ) {
                        if ( !d[i] ) { d[i] = x; return; }
                        else          x ^= d[i];
                }
        }
}
inline void Merge () { // 化简线性基
        for ( int i = 0; i <= mxBit; i ++ ) {
                for ( int j = i + 1; j <= mxBit; j ++ ) {
                        if ( d[j] & (1ll << i) ) d[j] ^= d[i];
                }
        }
        for ( int i = 0; i <= mxBit; i ++ ) if ( d[i] ) l[cnt ++] = d[i];
}
int main () {
        cin >> n >> m;
        for ( int i = 0; i < m; i ++ ) {
                string s; cin >> s;
                ll x = 0; for ( int i = 0; i < n; i ++ ) x = x * 2 + (s[i] == 'O');
                Insert ( x );
        }
        Merge ();
        cout << (1ll << cnt) % mod << endl;
}
```


