# 🔗
https://ac.nowcoder.com/acm/contest/11170/C

# 💡
我们可以发现如下性质：(1~9)为计数次数出现个数  
n=1时 (1 ~ 9)就是答案，所以9出现过1次，别的都是0次  
n=2时 (1 ~ 9)+(1 ~ 8)+(1 ~ 7)+..+(1 ~ 1)得到: 9一次，8一次，7一次，...，1一次  
n=3时 (1 ~ 9)+..+(1 ~ 1)  +  (1 ~ 8)+..+(1 ~ 1) + (1 ~ 7)+..+(1 ~ 1) + .. + (1 ~ 1)得到9一次，8两次，7三次，....，1九次
...后面一个自己手算一下即可  
得到下表
<table>
<tr>
<th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th>
</tr>
<tr>
<td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
</tr>
<tr>
<td>2</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
</tr>
<tr>
<td>3</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td>
</tr>
<tr>
<td>4</td><td>45</td><td>37</td><td>29</td><td>21</td><td>15</td><td>10</td><td>6</td><td>3</td><td>1</td>
</tr>
<tr>..</tr><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td><td>..</td>
</table>  
会发现每一次更新当点都是上一行这个点之后的和（证明方式有点不好打，大家可以自己试试）  
而如果一行一行递推显然时间爆T，那么怎么算呢  
（一位学长给我说可以用分块打表）  
这里我用的是矩阵ksm：  
用a[i]表示计数次数为i次出现的次数   
建立矩阵乘法如下  
<table>
<tr>
<td>1</td><td>0</td><td>0</td><td>0</td><td>...</td><td>0</td><td rowspan="6" valign="top">^n</td><td>a[1]</td>
</tr>
<tr>
<td>1</td><td>1</td><td>0</td><td>0</td><td>...</td><td>0</td><td>a[2]</td>
</tr>
<tr>
<tr>
<td>1</td><td>1</td><td>1</td><td>0</td><td>...</td><td>0</td><td>a[3]</td>
</tr>
<tr>
<td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td>
</tr>
<tr>
<td>1</td><td>1</td><td>1</td><td>1</td><td>...</td><td>1</td><td>a[9]</td>
</tr>
</table>  
因为a[i]都保存了上一行的前i个，所以我们递推时不能改变原有的值，从后往前递推，就将方矩阵和竖矩阵倒过来建  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >  
  
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <string>
#include <vector>
#include <cstdio>
#include <stack>
#include <queue>
#include <cmath>
#include <map>
#include <set>
#define G 10.0
#define LNF 1e18
#define eps 1e-6
#define ll long long
#define INF 0x7FFFFFFF
#define PI acos(-1.0)
#define pb(x) push_back(x)
#define SP system("pause")
#define mm(a, b) memset(a, b, sizeof(a))
#define fir(i, a, n) for (int i = a; i <= n; i++)
#define rif(i, a, n) for (int i = a; i >= n; i--)
#define each_cass(cass) for (scanf("%d", &cass); cass; cass--)

using namespace std;

const ll mod = 100019;
struct Matrix{
    ll m[10][10];
    Matrix(int flag)//构造函数
    {
        fir(i, 1, 9) fir(j, 1, 9) m[i][j] = flag * (i == j);
    }
    Matrix Mul(Matrix a,Matrix b)//矩阵乘
    {
        Matrix ans(0);
        fir(i, 1, 9) fir(j, 1, 9) fir(k, 1, 9) ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
        return ans;
    }
    Matrix ksm(Matrix a,ll b)//ksm
    {
        Matrix ans(1);
        while(b){
            if(b&1)
                ans = Mul(ans, a);
            a = Mul(a, a);
            b >>= 1;
        }
        return ans;
    }
};

int main()
{
    ll n;
    cin >> n;
    ll a[10] = {0, 1, 0, 0, 0, 0, 0, 0, 0, 0};//这里算的时候拿a[i]表示9-i+1计数出现的次数，并且初始数组为n=1的情况
    Matrix cur(1);
    fir(i, 1, 9) fir(j, 1, 9) cur.m[i][j] = 1*(j<=i);
    cur = cur.ksm(cur, n);
    
    //sum出a[i]*i的结果
    ll sum = 0;
    fir(i,1,9)
    fir(j,1,9)
    {
        sum = (sum + cur.m[i][j] * a[j]%mod)%mod;
    }
    cout << sum << endl;
    return 0;
}

```
