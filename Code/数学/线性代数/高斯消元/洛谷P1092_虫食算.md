# 🔗
<a href="https://www.luogu.com.cn/problem/P1092"><img src="https://i.loli.net/2021/11/12/3ZjBEs2iLJ9r8qU.png"></a>

# 💡
 <img src="https://latex.codecogs.com/svg.image?\inline&space;n\le&space;26" title="\inline n\le&space;26" /> ，现在最不确定且影响我们枚举的因素就是第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  位是否进位  
我们设  <img src="https://latex.codecogs.com/svg.image?\inline&space;d_i" title="\inline d_i" />  表示第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  位是否向  <img src="https://latex.codecogs.com/svg.image?\inline&space;i+1" title="\inline i+1" />  位进位，输入三个串  <img src="https://latex.codecogs.com/svg.image?\inline&space;a,b,c" title="\inline a,b,c" /> ， 那么可以列一个方程：  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}a_i+b_i+d_{i-1}&=c_i+n\times&space;d_i\\a_i+b_i-c_i&=n\times&space;d_i-d_{i-1}\end{aligned}" title="\inline \begin{aligned}a_i+b_i+d_{i-1}&=c_i+n\times d_i\\a_i+b_i-c_i&=n\times d_i-d_{i-1}\end{aligned}" />   
  
则我们当前有两个系数矩阵（设左为  <img src="https://latex.codecogs.com/svg.image?\inline&space;A" title="\inline A" />  右为  <img src="https://latex.codecogs.com/svg.image?\inline&space;B" title="\inline B" /> )  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;A_{ij}" title="\inline A_{ij}" />  表示在第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  项，  <img src="https://latex.codecogs.com/svg.image?\inline&space;'A'+j" title="\inline 'A'+j" />  这个字符的系数  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;B_{ij}" title="\inline B_{ij}" />  表示在第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  项，进位  <img src="https://latex.codecogs.com/svg.image?\inline&space;d_j" title="\inline d_j" />  的系数  
  
我们将  <img src="https://latex.codecogs.com/svg.image?\inline&space;[A]" title="\inline [A]" />  用高斯消元消至只有主对角线不为  <img src="https://latex.codecogs.com/svg.image?\inline&space;0" title="\inline 0" />  （同时  <img src="https://latex.codecogs.com/svg.image?\inline&space;[B]" title="\inline [B]" />  也跟着消）  
则  <img src="https://latex.codecogs.com/svg.image?\inline&space;\sum\limits_{j=0}^{n-1}\frac{g_{ij}}{A_{ii}}" title="\inline \sum\limits_{j=0}^{n-1}\frac{g_{ij}}{A_{ii}}" />  就是  <img src="https://latex.codecogs.com/svg.image?\inline&space;'A'+i" title="\inline 'A'+i" />  所表示的数值  
  
由于我们有成立条件：  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;1." title="\inline 1." /> 不同字符数值不同    
 <img src="https://latex.codecogs.com/svg.image?\inline&space;2." title="\inline 2." />  数值  <img src="https://latex.codecogs.com/svg.image?\inline&space;\in[0,n-1]" title="\inline \in[0,n-1]" />   
所以我们二进制枚举  <img src="https://latex.codecogs.com/svg.image?\inline&space;\{d\}" title="\inline \{d\}" />  每次检查一下是否合法即可  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N = 30;
int n;
string s1, s2, s3;
int A[N][N], B[N][N];
int d[N];

inline void Matrix () {
        for ( int i = 0; i < n; i ++ ) {
                A[i][s1[n - i - 1] - 'A'] ++;
                A[i][s2[n - i - 1] - 'A'] ++;
                A[i][s3[n - i - 1] - 'A'] --;
                B[i][i] = n;
                if ( i ) B[i][i - 1] = -1;
        }
}
inline int Gcd ( int a, int b ) { return b ? Gcd ( b, a % b ) : a; }
inline void Gauss () {
        for ( int r = 0, c = 0; c < n; c ++ ) {
                int t = r;
                for ( int i = r; i < n; i ++ ) if ( abs(A[i][c]) > abs(A[t][c]) ) t = i;
                if ( A[t][c] == 0 ) continue;
                swap ( A[r], A[t] ); swap ( B[r], B[t] );
                for ( int i = 0; i < n; i ++ ) {
                        if ( i == r ) continue;
                        if ( A[i][c] ) {
                                int t1 = A[i][c] / Gcd ( A[i][c], A[r][c] );
                                int t2 = A[r][c] / Gcd ( A[i][c], A[r][c] );
                                for ( int j = 0; j < n; j ++ ) 
                                        A[r][j] *= t1, 
                                        B[r][j] *= t1,
                                        A[i][j] = A[i][j] * t2 - A[r][j],
                                        B[i][j] = B[i][j] * t2 - B[r][j];
                        }
                }
                r ++;
        }
}

int vis[N], res[N];
inline bool Check () {
        memset ( vis, 0, sizeof vis );
        for ( int i = 0; i < n; i ++ ) {
                res[i] = 0;
                for ( int j = 0; j < n; j ++ ) res[i] += d[j] * B[i][j];

                if ( 
                        res[i] % A[i][i] || 
                        res[i] / A[i][i] < 0 || 
                        res[i] / A[i][i] >= n || 
                        vis[res[i] /= A[i][i]] 
                ) return false;

                vis[res[i]] = 1;
        }
        return true;
}

int main () {
        cin >> n >> s1 >> s2 >> s3;
        Matrix ();
        Gauss ();
        for ( int i = 0; i < (1 << n); i ++ ) {
                for ( int j = 0; j < n; j ++ ) d[j] = (i & (1 << j)) ? 1 : 0;
                if ( Check () ) {
                        for ( int i = 0; i < n; i ++ ) cout << res[i] << (i < n - 1 ? " " : "");
                }
        }
}
```
