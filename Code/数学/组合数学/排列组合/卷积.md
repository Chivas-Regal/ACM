# 🔗
<a href="https://ac.nowcoder.com/acm/problem/218216"><img src="https://img-blog.csdnimg.cn/20210409231427628.png"></a>

# 💡
既然要mex，那么：  
在i=0时，a[1 ~ (n-1)]*b[1 ~ (n-1)]都可行  
在i=1时，a[0]*b[0 ~ (n-1)]与b[0]*a[0 ~ (n-1)]都可行  
在i=2时，只有a[1]*b[0]和a[0]*b[1]可行  
从i=3开始，任何数都不满足，所以都是0  
而对于区间和时我们只需记录前缀和就行了，相减时要加上一个mod防止结果为负  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int maxn = 1e5 + 100;
const ll mod = 998244353;
ll a[maxn];
ll b[maxn];
ll sum_a[maxn] = {0};//a的前缀和
ll sum_b[maxn] = {0};//b的前缀和
ll n;
int main()
{
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lld", &a[i]), sum_a[i] = (sum_a[i - 1] + a[i]) % mod;
    for (int i = 1; i <= n; i++)
        scanf("%lld", &b[i]), sum_b[i] = (sum_b[i - 1] + b[i]) % mod;
    for (int i = 1; i <= n; i++)//这里计数都+1，方便统计sum_a[0]与sum_b[0]
    {
        if (i == 1)
            printf("%lld", (sum_a[n] + mod - sum_a[1]) * (sum_b[n] + mod - sum_b[1]) % mod);
        else if (i == 2)
            printf("%lld",  (a[1] * (sum_b[n] + mod - sum_b[0]+mod-b[2]) % mod + b[1] * (sum_a[n] + mod - sum_a[0]+mod-a[2]) % mod +mod- /*去重*/a[1] * b[1] % mod)%mod);
        else if (i == 3)
            printf("%lld", (a[1] * b[2] % mod + a[2] * b[1] % mod) % mod);
        else
            printf("%lld", 0ll);
        if (i != n)
            printf(" ");
    }
    return 0;
}
```
