# 🔗
<a href="https://www.luogu.com.cn/problem/P1450"><img src="https://i.loli.net/2021/11/10/27LQvBmkElueGT6.png"></a>

# 💡
本题尝试生成函数  <img src="https://latex.codecogs.com/svg.image?\inline&space;10" title="\inline 10" /> 分，  <img src="https://latex.codecogs.com/svg.image?\inline&space;FFT" title="\inline FFT" /> 优化还是  <img src="https://latex.codecogs.com/svg.image?\inline&space;10" title="\inline 10" /> 分...  
  
看了眼时间，开始老老实实想背包   
（不会吧  <img src="https://latex.codecogs.com/svg.image?\inline&space;O(n)" title="\inline O(n)" /> 是极限而且不一定过？  
  
提前给定的  <img src="https://latex.codecogs.com/svg.image?\inline&space;c[0...4]" title="\inline c[0...4]" /> 一定有其用意，先拿完全背包预处理一下  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" />  数组  
但是让多重背包，我们就容斥减掉不合法的  
假设我们枚举第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 个，此时我们如果预先拿走  <img src="https://latex.codecogs.com/svg.image?\inline&space;d[i]+1" title="\inline d[i]+1" /> 个，那么之后的任意选择方式都是不合法的  
此时不合法的也就是容积  <img src="https://latex.codecogs.com/svg.image?\inline&space;n-c[i]\times&space;(d[i]+1)" title="\inline n-c[i]\times&space;(d[i]+1)" /> 的背包，我们减去  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[n-c[i]*(d[i]+1)]" title="\inline dp[n-c[i]*(d[i]+1)]" />   
当然因为是容斥，所以我们还要加回来提前两个不合法，减掉提前三个不合法...   
  
二进制枚举，观察时间复杂的，  <img src="https://latex.codecogs.com/svg.image?\inline&space;T*2^4" title="\inline T*2^4" /> 很正常的时间    
  
好家伙，容斥改完全背包为多重背包...

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>

#define ll long long

using namespace std;

const int N = 1e5 + 10;
int c[N], d[N], n;
ll dp[N];

inline void Solve () {
        for ( int i = 0; i < 4; i ++ ) cin >> d[i];
        cin >> n;
        ll res = dp[n];
        for ( int i = 0; i < (1 << 4); i ++ ) { // 枚举提前选哪些物品超过限制
                int cnt = 0; ll cur = 0;
                for ( int j = 0; j < 4; j ++ ) {
                        if ( i & (1 << j) ) {
                                cnt ++;
                                cur += (ll)c[j] * (d[j] + 1);
                        }
                }
                if ( cur > n || cur == 0 ) continue; // n以下没有不合法解 或者 全都不选不构成解也不构成不合法解
                if ( cnt & 1 ) res -= dp[n - cur];
                else           res += dp[n - cur];
        }
        cout << res << endl;
}

int main () {
        for ( int i = 0; i < 4; i ++ ) cin >> c[i]; 
        dp[0] = 1; for ( int i = 0; i < 4; i ++ ) for ( int j = c[i]; j < N; j ++ ) dp[j] += dp[j - c[i]]; 

        int cass; cin >> cass; while ( cass -- ) {
                Solve ();
        }
}
```
