# 🔗
<a href="https://www.luogu.com.cn/problem/P1169"><img src="https://i.loli.net/2021/11/30/6qftiQR9NW5yUYJ.png"></a>

# 💡
求最大子全满足要求的矩阵问题  
应该一眼想到悬线法  

这道题每一个单位都可以满足哟求，所以初始化都是横  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 竖  <img src="https://latex.codecogs.com/svg.image?\inline&space;1" title="\inline 1" />   
拉线和缩线的时候两者都满足要求的判断就是  <img src="https://latex.codecogs.com/svg.image?\inline&space;\[a[i][j]\oplus&space;a[i-1][j]\neq0\]" title="\inline [a[i][j]^a[i-1][j]\neq0]" /> 或者  <img src="https://latex.codecogs.com/svg.image?\inline&space;[a[i][j]\oplus&space;a[i][j\pm1]\neq0]" title="\inline [a[i][j]\oplus&spacea[i][j\pm1]\neq0]" />   

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N = 1e3 + 10;
char Map[N][N];
int lft[N][N], rgt[N][N], up[N][N];

int main () {

        int n, m; cin >> n >> m;
        for ( int i = 1; i <= n; i ++ ) for ( int j = 1; j <= m; j ++ ) cin >> Map[i][j];

        for ( int i = 1; i <= n; i ++ ) {
                for ( int j = 1; j <= m; j ++ )     lft[i][j] = rgt[i][j] = j, up[i][j] = 1;
                for ( int j = 2; j <= m; j ++ )     if ( Map[i][j] ^ Map[i][j - 1] ) lft[i][j] = lft[i][j - 1]; 
                for ( int j = m - 1; j >= 0; j -- ) if ( Map[i][j] ^ Map[i][j + 1] ) rgt[i][j] = rgt[i][j + 1]; 
                if ( i >= 2 ) 
                        for ( int j = 1; j <= m; j ++ ) 
                                if ( Map[i][j] ^ Map[i - 1][j] ) 
                                        up[i][j] = up[i - 1][j] + 1,
                                        lft[i][j] = max(lft[i][j], lft[i - 1][j]),
                                        rgt[i][j] = min(rgt[i][j], rgt[i - 1][j]);
        }
        int res1 = 0, res2 = 0;
        for ( int i = 1; i <= n; i ++ ) {
                for ( int j = 1; j <= n; j ++ ) {
                        res1 = max(res1, min(up[i][j], rgt[i][j] - lft[i][j] + 1) * min(up[i][j], rgt[i][j] - lft[i][j] + 1) ),
                        res2 = max(res2, up[i][j] * (rgt[i][j] - lft[i][j] + 1)); // 面积 = 长 * 高
                }
        }
        cout << res1 << endl << res2 << endl;
}
```
