# 🔗
<a href="https://www.luogu.com.cn/problem/P5484"><img src="https://s2.loli.net/2022/01/14/vo2L6X9tDRHgKW4.png"></a>

# 💡
## 任务简化

要匹配的话我们按要求把字符串  <img src="https://latex.codecogs.com/svg.image?\inline&space;A" title="\inline A" />  转译一下  
由于我们可以在字符串  <img src="https://latex.codecogs.com/svg.image?\inline&space;B" title="\inline B" />  中加入任何字符变成 <img src="https://latex.codecogs.com/svg.image?\inline&space;A" title="\inline A" />  
反过来就是问我们在字符串 <img src="https://latex.codecogs.com/svg.image?\inline&space;A" title="\inline A" /> 的子序列中能找到多少个 <img src="https://latex.codecogs.com/svg.image?\inline&space;B" title="\inline B" />  

## 问题解法

这个问题就很简单了  
我们枚举字符串 <img src="https://latex.codecogs.com/svg.image?\inline&space;A" title="\inline A" /> 的下标  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  ， <img src="https://latex.codecogs.com/svg.image?\inline&space;A_i" title="\inline A_i" />  能做出的贡献就是：  
对于所有的  <img src="https://latex.codecogs.com/svg.image?\inline&space;B_j=A_i" title="\inline B_j=A_i" />  ，若  <img src="https://latex.codecogs.com/svg.image?\inline&space;j>1" title="\inline j>1" />  ，那么在字符串 <img src="https://latex.codecogs.com/svg.image?\inline&space;A" title="\inline A" /> 的所有  <img src="https://latex.codecogs.com/svg.image?\inline&space;B_{j-1}" title="\inline B_{j-1}" />  字符全都接着  <img src="https://latex.codecogs.com/svg.image?\inline&space;B_j" title="\inline B_j" />  这个字符再往后走一步  
如果  <img src="https://latex.codecogs.com/svg.image?\inline&space;j=0" title="\inline j=0" />  就是他自己要  <img src="https://latex.codecogs.com/svg.image?\inline&space;+1" title="\inline +1" />    
那就是妥妥的 计数  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" />  了
  
## 伪代码设计
  
所以我们设置  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp_j" title="\inline dp_j" />  表示外层枚举到  <img src="https://latex.codecogs.com/svg.image?\inline&space;A_i" title="\inline A_i" />  时，子序列结尾为  <img src="https://latex.codecogs.com/svg.image?\inline&space;B_j" title="\inline B_j" />  的方案数  
那么转移方程为 ：  
<img src="https://latex.codecogs.com/svg.image?\inline&space;\begin{aligned}&space;&space;&for\;i[0\longrightarrow&space;n-1]:\\&space;&space;&\quad&space;for\;j[m-1\longrightarrow&space;0]:\\&space;&space;&\quad\quad\quad&space;if\;j>0:&dp_j=dp_j&plus;dp_{j-1}\\&space;&space;&\quad\quad\quad&space;else:&dp_j=dp_j&plus;dp_{j-1}\end{aligned}" title="\inline \begin{aligned} &for\;i[0\longrightarrow n-1]:\\ &\quad for\;j[m-1\longrightarrow 0]:\\ &\quad\quad\quad if\;j>0:&dp_j=dp_j+dp_{j-1}\\ &\quad\quad\quad else:&dp_j=dp_j+dp_{j-1}\end{aligned}" />   
>注意，这里倒着枚举  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" />  是防止同一步之前更新过的  <img src="https://latex.codecogs.com/svg.image?\inline&space;j-1" title="\inline j-1" />  加给  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >

数过大，普通的类型会溢出  
这里只给出直观的普通类型 C++ 代码，改大数可以自行更改（我用的是 java
```cpp
ll dp[2005];

int main () {
        ll n, m; cin >> n >> m;
        string s, t; cin >> s >> t;
        // 转义
        for ( int i = 0; i < n; i ++ ) {
                if ( s[i] == 'A' ) s[i] = 'T';
                else if ( s[i] == 'T' ) s[i] = 'A';
                else if ( s[i] == 'C' ) s[i] = 'G';
                else s[i] = 'C'; 
        } 
        // 计数
        for ( int i = 0; i < n; i ++ ) {
                for ( int j = m - 1; j >= 0; j -- ) {
                        if ( s[i] == t[j] ) {
                                if ( j ) dp[j] += dp[j - 1];
                                else dp[j] ++;
                        }
                }
        }
        cout << dp[m - 1] << endl;
}
```
