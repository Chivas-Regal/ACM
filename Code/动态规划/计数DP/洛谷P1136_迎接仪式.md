# 🔗
<a href="https://www.luogu.com.cn/problem/P1136"><img src="https://i.loli.net/2021/11/27/9vEbG1QScmyFPCe.png"></a>

# 💡
换与不换是一种决策，可以用  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" />  实现  
换来换去太绕了，我们可以计算直接改变的  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> 和  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'z'" /> 数量，最后计算这两个数量一样的  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" /> 就行了  
  
那么我们可以记录状态  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j][k][id]" title="\inline dp[i][j][k][id]" /> 表示在第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 位之前，换来了  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 个  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> 和  <img src="https://latex.codecogs.com/svg.image?\inline&space;k" title="\inline k" /> 个  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'z'" /> 且这一位是  <img src="https://latex.codecogs.com/svg.image?\inline&space;id=0?'j':'z'" title="\inline id=0?'j':'z'" /> ，的最大价值  
  
那么我们线性枚举，枚举第几位，枚举换出了多少个  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> 和多少个  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'z'" />   
**在第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 位**   

如果这一位本身是  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'z'" /> ，我们可以选择换还是不换  
**换：** 产出了一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'z'" /> ，上一个状态耗费的是  <img src="https://latex.codecogs.com/svg.image?\inline&space;j-1" title="\inline j-1" /> 个换出  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'z'" /> 的方式，且可以因上一步最后为  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> 的位数加价值，或者为  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'z'" /> 不改变， <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j][k][1]=max(dp[i-1][j-1][k][0]+1,dp[i-1][j-1][k][1])" title="\inline dp[i][j][k][1]=max(dp[i-1][j-1][k][0]+1,dp[i-1][j-1][k][1])" />  
**不换：** 本身是  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> 也不会受到上一步影响，那么就简单汇聚一下， <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j][k][0]=max(dp[i-1][j][k][0],dp[i-1][j][k][1])" title="\inline dp[i][j][k][0]=max(dp[i-1][j][k][0],dp[i-1][j][k][1])" />     

如果这一位是  <img src="https://latex.codecogs.com/svg.image?\inline&space;'z'" title="\inline 'j'" />   
**换：** 变成了  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> ，与上一步无影响也耗费了一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;k" title="\inline k" /> ，上个状态就是  <img src="https://latex.codecogs.com/svg.image?\inline&space;k-1" title="\inline k-1" /> ，汇聚一下， <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j][k][0]=max(dp[i-1][j][k-1][0],dp[i-1][j][k-1][1])" title="\inline dp[i][j][k][0]=max(dp[i-1][j][k-1][0],dp[i-1][j][k-1][1])" />   
**不换：**  本身可以和上一步的  <img src="https://latex.codecogs.com/svg.image?\inline&space;'j'" title="\inline 'j'" /> 产生影响，  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j][k][1]=max(dp[i-1][j][k][1],dp[i-1][j][k][0]+1)" title="\inline dp[i][j][k][1]=max(dp[i-1][j][k][1],dp[i-1][j][k][0]+1)" />   
  
最后遍历一下修改量  <img src="https://latex.codecogs.com/svg.image?\inline&space;jk" title="\inline jk" /> ，选择最大的  <img src="https://latex.codecogs.com/svg.image?\inline&space;max(dp[n][jk][jk][0],dp[n][jk][jk][1])" title="\inline max(dp[n][jk][jk][0],dp[n][jk][jk][1] )" />  
  
其中注意，初始是前面的都弄好了，且这一位不会产生影响，  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[0][0][0][1]=0" title="\inline dp[0][0][0][1]=0" />   

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
int N, K;
string s;

int dp[510][105][105][2];  

int main () {
        cin >> N >> K >> s; s = "0" + s;

        memset ( dp, -0x3f3f3f3f, sizeof dp );
        dp[0][0][0][1] = 0;

        for ( int i = 1; i <= N; i ++ ) {
                for ( int j = 0; j <= K; j ++ ) {
                        for ( int k = 0; k <= K; k ++ ) {
                                if ( s[i] == 'j' ) {
                                        dp[i][j][k][0] = max ( dp[i - 1][j][k][0], dp[i - 1][j][k][1] );
                                        if ( j ) dp[i][j][k][1] = max ( dp[i - 1][j - 1][k][0] + 1, dp[i - 1][j - 1][k][1] );
                                } else {
                                        dp[i][j][k][1] = max ( dp[i - 1][j][k][1], dp[i - 1][j][k][0] + 1 );
                                        if ( k ) dp[i][j][k][0] = max ( dp[i - 1][j][k - 1][0], dp[i - 1][j][k - 1][1] );
                                }
                        }
                }
        }

        int res = -0x3f3f3f3f;
        for ( int jk = 0; jk <= K; jk ++ ) {
                res = max ( res, max (dp[N][jk][jk][0], dp[N][jk][jk][1]) );
        }
        cout << res << endl;
}
```
