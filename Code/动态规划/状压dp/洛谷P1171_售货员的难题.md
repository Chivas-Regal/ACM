# 🔗
<a href="https://www.luogu.com.cn/problem/P1171"><img src="https://i.loli.net/2021/11/30/Cbq2Jav6L1XVWpm.png"></a>
           
# 💡
这个题目数据对全排列很难不心动  
然后设置  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j]" title="\inline dp[i][j]" /> 表示第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  个点走的是  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" />   
可以通过爆搜剪枝做  
  
但是代码很长  
可以想到，全排列中，每走过一个点，那么这个点其实就在这一趟中没什么用了  
而且第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 个点走的是  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 的话似乎也没有用到前面的排列  
那么不如就记录某个点是否走过了  
这样走过的点会形成一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;01" title="\inline 01" />  状态：  <img src="https://latex.codecogs.com/svg.image?\inline&space;s" title="\inline s" />   
我们用这个状态进行推，设置  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[s][i]" title="\inline dp[i][j]" /> 表示第  <img src="https://latex.codecogs.com/svg.image?\inline&space;s" title="\inline s" /> 状态下，最后走到的点是  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />   
此时可以新换入一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;1" title="\inline 1" /> 来表示新的状态，即如果第  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 位是  <img src="https://latex.codecogs.com/svg.image?\inline&space;0" title="\inline 0" /> 的话，就可以通过  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[s][i]" title="\inline dp[s][i]" /> 推过去，距离加了  <img src="https://latex.codecogs.com/svg.image?\inline&space;g[i][j]" title="\inline g[i][j]" />   
    
那么转移方程就是： <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[s|(1<<j)][j]=min(dp[s|(1<<j)][j],dp[s][i]+g[i][j])" title="\inline dp[s|(1<<j)][j]=min(dp[s|(1<<j)][j],dp[s][i]+g[i][j])" />  

最后再计算一下走到  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 后再走回去的距离  
此时所有的点都走过了，所以状态是全  <img src="https://latex.codecogs.com/svg.image?\inline&space;1" title="\inline 1" /> 的

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
int dp[1050000][20]; // dp[i][j]: i状态下，最后一个点走到j
int g[20][20];

int n;

int main () {
        memset ( dp, 0x3f3f3f3f, sizeof dp );

        cin >> n;
        for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < n; j ++ ) cin >> g[i][j];

        dp[1][0] = 0;
        
        for ( int s = 0; s < (1 << n); s ++ ) {
                for ( int i = 0; i < n; i ++ ) { // s状态下从i出发
                        if ( dp[s][i] != 0x3f3f3f3f ) {
                                for ( int j = 0; j < n; j ++ ) {
                                        if ( (s & (1 << j)) == 0 ) { // 没走到过j，那就走到j
                                                int news = s | (1 << j); // 走到j后是一个新状态
                                                dp[news][j] = min ( dp[news][j], dp[s][i] + g[i][j] );
                                        }
                                }
                        }
                }
        }

        int res = 0x3f3f3f3f;
        for ( int i = 0; i < n; i ++ ) {
                res = min ( res, dp[(1 << n) - 1][i] + g[i][0] ); // 每个点都走过一遍的状态，从i走回0
        }
        cout << res << endl;
}
```
