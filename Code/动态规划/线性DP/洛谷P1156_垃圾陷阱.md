# 🔗
<a href="https://www.luogu.com.cn/problem/P1156"><img src="https://i.loli.net/2021/11/28/eiHTZIhyaS9XNjr.png"></a>

# 💡
这道题，每个地方吃垃圾和踩垃圾，两种中决策出来一个  
受到饱腹感的限制  
  
这不就  <img src="https://latex.codecogs.com/svg.image?\inline&space;DP" title="\inline DP" /> 吗  
我们想要进行取最优的是高度，所以我们状态表示的是高度  
而那两个限制就放在维度中  
令  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j]" title="\inline dp[i][j]" /> 表示第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 个垃圾，有  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 饱腹感的最高高度  
  
那么我们在枚举到  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />  的时候，有吃和踩两种  
踩无法让饱腹感更高但是可以贡献高度：  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j]=max(dp[i-1][j+gbgs[i].t-gbgs[i-1].t]+gbgs[i].h)" title="\inline dp[i][j]=max(dp[i-1][j],dp[i-1][j+gbgs[i].t-gbgs[i-1].t]+gbgs[i].h)" />   
吃无法让高度更高但是要更新更高的饱腹感：  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j+gbgs[i].f]=max(dp[i-1][j+gbgs[i].t-gbgs[i-1].t])" title="\inline dp[i][j+gbgs[i].f]=max(dp[i][j+gbgs[i].f],dp[i-1][j+gbgs[i].t-gbgs" />   
  
设计一个饱腹感变量让它每次都吃  
也就是最高的饱腹感  
不仅用作遍历，还用作判断，如果中间断时间过大，那么一定是走不上去就被饿死了，所以中间判断一下够不够减这个时间，不够的话就根据上一次时间和饱腹感输出时间  
如果中间  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[][]" title="\inline dp" /> 比  <img src="https://latex.codecogs.com/svg.image?\inline&space;D" title="\inline D" /> 更高了，那么就直接输出这个时间，能走上去  
  
最后还是没走上去的话，就每次都吃统计一下总饱腹感，然后输出这个饱腹感就是坚持的时间  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>

#define ll long long

using namespace std;

int D, G;
struct Gbg {
        int t, f, h;
};
vector<Gbg> gbgs;

int no_hungry = 10;
int dp[110][4010]; // dp[i][j]：第i个垃圾，有j饱腹感，表示最高高度

int main () {
        memset(dp, -1, sizeof dp );

        cin >> D >> G;
        for ( int i = 0; i < G; i ++ ) {
                int t, f, h; cin >> t >> f >> h;
                gbgs.push_back({t, f, h});
        }
        gbgs.push_back({0, 0, 0});
        sort ( gbgs.begin(), gbgs.end(), [&]( Gbg a, Gbg b ) { return a.t < b.t; });

        dp[0][10] = 0;

        for ( int i = 1; i <= G; i ++ ) {
                if ( no_hungry - gbgs[i].t + gbgs[i - 1].t < 0 ) {
                        cout << gbgs[i - 1].t + no_hungry << endl;
                        return 0;
                }
                no_hungry -= gbgs[i].t - gbgs[i - 1].t;
                for ( int j = 0; j <= no_hungry; j ++ ) {
                        if ( dp[i - 1][j + gbgs[i].t - gbgs[i - 1].t] != -1 ) {
                                dp[i][j] = max ( dp[i][j], dp[i - 1][j + gbgs[i].t - gbgs[i - 1].t] + gbgs[i].h ),
                                dp[i][j + gbgs[i].f] = max ( dp[i][j + gbgs[i].f],  dp[i - 1][j + gbgs[i].t - gbgs[i - 1].t] );
                                if ( dp[i][j] >= D || dp[i][j + gbgs[i].f] >= D ) { cout << gbgs[i].t << endl; return 0; }
                        }
                }
                no_hungry += gbgs[i].f;
        }

        no_hungry = 10;
        for ( Gbg gbg : gbgs ) no_hungry += gbg.f;
        cout << no_hungry << endl;
}
```
