# 🔗
<a href="https://www.luogu.com.cn/problem/P1174"><img src="https://i.loli.net/2021/11/30/EfIzcHoMG7vWQbw.png"></a>

# 💡
很麻烦的一道  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" /> 加贪心  
首先每一次要选哪个点进行射击时决策，所以我们想到  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" />   
  
由于在不同的行花费不同的子弹能得到不同的价值，而我们有这个子弹数  
所以预处理出  

```cpp
int dn[210][210];  // 每一列往上打的最后落脚点是 'N'
int dy[210][210];  // 每一列往上打的最后落脚点是 'Y'

inline void pre_D ( int j ) {
        int cnt = N, k = 0;
        while ( cnt >= 1 ) {
                while ( cnt >= 1 && c[cnt][j] == 'Y' ) 
                        dy[j][k] += a[cnt][j],
                        cnt --;
                while ( cnt >= 1 && c[cnt][j] == 'N' )
                        k ++,
                        dn[j][k] = dy[j][k - 1] + a[cnt][j],
                        dy[j][k] = dn[j][k],
                        cnt --;
        }
}

for ( int j = 1; j <= M; j ++ ) pre_D ( j );
```  

其次是  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp" title="\inline dp" />   
由于限制为子弹数量和列数  
所以我们设置  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp[i][j]" title="\inline dp[i][j]" /> 表示在第  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 列用了  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 颗子弹的最大价值  
但是  <img src="https://latex.codecogs.com/svg.image?\inline&space;'N'" title="\inline 'N'" /> 和  <img src="https://latex.codecogs.com/svg.image?\inline&space;'Y'" title="\inline 'Y'" /> 不一样，他们会影响你是否用光你的子弹  

所以加一维  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1[i][j]" title="\inline dp1[i][j]" /> ：前  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 列刚好打到  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 颗子弹就可以停下  
  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2[i][j]" title="\inline dp2[i][j]" /> ：前  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 列没打完  <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 颗子弹就要停下了  

枚举:  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />列  
  <img src="https://latex.codecogs.com/svg.image?\inline&space;k" title="\inline k" />  有的的子弹数量   
 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" /> 用了的子弹数量

那么有三种情况  
   <img src="https://latex.codecogs.com/svg.image?\inline&space;1." title="\inline 1." />  没用完，对于  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1" title="\inline dp1" />:  <img src="https://latex.codecogs.com/svg.image?\inline&space;=max(dp2[j-1][k-x],dp1[j-1][k-x])+dy[j][x]" title="\inline =max(" />   
     
 <img src="https://latex.codecogs.com/svg.image?\inline&space;2." title="\inline 2." />  用完了，但是之前没有用完  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1[j][k]=max(dp1[j-1]k-x]+dy[j][x])" title="\inline dp1[j][k]=max(dp1[j-1]k-x]+dy[j][x])" />    
即前几步打完了，你这里就使劲走也不一定走到  <img src="https://latex.codecogs.com/svg.image?\inline&space;'N'" title="\inline 'N'" />  这个你满意的极限位置    

 <img src="https://latex.codecogs.com/svg.image?\inline&space;3." title="\inline 3." />  用完了，且之前也用完了  
 <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1[j][k]=max(dp2[j-1][k-x]+dn[j][x])" title="\inline dp1[i][j]=max(" />   
 即前几部没打完，你这里使劲走走到最后一步一定是  <img src="https://latex.codecogs.com/svg.image?\inline&space;'N'" title="\inline 'n'" />   

 由于子弹肯定打完最好，所以最后一步一定是  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1[m][k]" title="\inline dp1[m][k]" /> 


# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>

#define ll long long

using namespace std;

int N, M, K;
int a[210][210]; char c[210][210];
int dn[210][210];  // 每一列往上打的最后落脚点是 'N'
int dy[210][210];  // 每一列往上打的最后落脚点是 'Y'
int dp1[210][210]; // dp1[i][j]: 前 i 列刚好打到第 j 颗子弹就可以停
int dp2[210][210]; // dp2[i][j]: 前 i 列没打完第 j 颗子弹

inline void pre_D ( int j ) {
        int cnt = N, k = 0;
        while ( cnt >= 1 ) {
                while ( cnt >= 1 && c[cnt][j] == 'Y' ) 
                        dy[j][k] += a[cnt][j],
                        cnt --;
                while ( cnt >= 1 && c[cnt][j] == 'N' )
                        k ++,
                        dn[j][k] = dy[j][k - 1] + a[cnt][j],
                        dy[j][k] = dn[j][k],
                        cnt --;
        }
}

int main () {
        cin >> N >> M >> K;
        for ( int i = 1; i <= N; i ++ ) for ( int j = 1; j <= M; j ++ ) cin >> a[i][j] >> c[i][j];
        for ( int j = 1; j <= M; j ++ ) pre_D ( j );

        for ( int j = 1; j <= M; j ++ ) {                 // 枚举每一列
                for ( int k = 0; k <= K; k ++ ) {         // 枚举有 k 发子弹
                        for ( int x = 0; x <= k; x ++ ) { // 枚举用了 x 发子弹
                                dp2[j][k] = max ( dp2[j][k], max(dp2[j - 1][k - x], dp1[j - 1][k - x]) + dy[j][x] ); // 没打完，你不一定走到 'N' 这个你满意的极限位置
                                if ( x < k ) dp1[j][k] = max ( dp1[j][k], dp1[j - 1][k - x] + dy[j][x] ); // 前几步打完了，你这里就eng走也不一定走到 'N' 这个你满意的极限位置
                                if ( x > 0 ) dp1[j][k] = max ( dp1[j][k], dp2[j - 1][k - x] + dn[j][x] ); // 前几步没打完，你这里就eng走单必须要走到 'N' 这个你满意的极限位置
                        }
                }
        }
        cout << dp1[M][K] << endl; // 打 'Y' 上会得到反馈（再送你一颗继续打，所以最后一发一定要打在 'N' 上
}
```
