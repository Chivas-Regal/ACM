# 🔗
<a href="https://www.luogu.com.cn/problem/P1108"><img src="https://i.loli.net/2021/11/12/xedCcs7TWoPyuV2.png"></a>

# 💡
第一问仔细一分析就知道是个最长下降子序列  
那么关键就是第二问：求最长下降子序列的个数  
是 [这道题](https://codeforces.com/gym/102163/problem/C)的深化版，就是多了一份同样的数列去重  
去重是最难想的，因为没有去重的话我们每次就以 <img src="https://latex.codecogs.com/svg.image?\inline&space;j" title="\inline j" /> 更新  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" /> 的时候都递加一下这个长度的数量即可  
  
求最长下降子序列的时候是前缀一个个递推的  
我们在这里可以接着递推的时候求  
设置  <img src="https://latex.codecogs.com/svg.image?\inline&space;\{dp2\}" title="\inline \{dp2\}" /> 为方案数  <img src="https://latex.codecogs.com/svg.image?\inline&space;\{dp\}" title="\inline \{dp\}" /> 数组，  <img src="https://latex.codecogs.com/svg.image?\inline&space;\{dp1\}" title="\inline \{dp1\}" /> 是前缀最长下降子序列数组  
  
如果  <img src="https://latex.codecogs.com/svg.image?\inline&space;a_i=a_j" title="\inline a_i=a_j" /> 且  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp_i=dp_j" title="\inline dp_i=dp_j" /> 说明转移给  <img src="https://latex.codecogs.com/svg.image?\inline&space;a_j" title="\inline a_j" /> 的也可以以同样的方式转移给  <img src="https://latex.codecogs.com/svg.image?\inline&space;a_i" title="\inline a_i" /> ，那么此时我们就不需要  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2_j" title="\inline dp2_j" /> 了，直接用  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2_i" title="\inline dp2_i" /> 就可以表示  
如果  <img src="https://latex.codecogs.com/svg.image?\inline&space;a_j>a_i" title="\inline a_j>a_i" /> 且  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1_j+1=dp1_i" title="\inline dp1_j+1=dp1_i" /> ，则说明这里有  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1_i" title="\inline dp1_i" /> 通过  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1_j" title="\inline dp1_j" /> 转移来  
所以我们在方案数  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2_i" title="\inline dp2_i" /> 可以继承  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2_j" title="\inline dp2_j" /> 即  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2_i+=dp2_i" title="\inline dp2_i+=dp2_i" />   
  
我们可以顺求  <img src="https://latex.codecogs.com/svg.image?\inline&space;max\{dp1\}=res1" title="\inline max\{dp1\}=res1" /> 
处理完之后累加一下每一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp1=res" title="\inline dp1=res" /> 的  <img src="https://latex.codecogs.com/svg.image?\inline&space;dp2" title="\inline dp2" />  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>

#define ll long long

using namespace std;

const int N = 1e4;
int n, a[N];
ll dp1[N], dp2[N];
ll res1, res2;

int main () {
        cin >> n;
        for ( int i = 0; i < n; i ++ ) {
                cin >> a[i]; 
                dp1[i] = 1;
                for ( int j = 0; j < i; j ++ ) if ( a[j] > a[i] ) dp1[i] = max ( dp1[i], dp1[j] + 1 );
                for ( int j = 0; j < i; j ++ ) {
                        if ( a[i] == a[j] && dp1[i] == dp1[j] ) dp2[j] = 0;
                        else if ( a[j] > a[i] && dp1[j] + 1 == dp1[i] ) dp2[i] += dp2[j];
                }
                if ( !dp2[i] ) dp2[i] = 1;
                res1 = max ( res1, dp1[i] );
        }
        for ( int i = 0; i < n; i ++ ) if ( dp1[i] == res1 ) res2 += dp2[i];
        cout << res1 << " " << res2 << endl; 
        return 0;
}
```
