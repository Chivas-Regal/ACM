# ğŸ”—

<a href="https://www.luogu.com.cn/problem/P1225"><img src="https://img-blog.csdnimg.cn/eafed431a13b40aab40c6f42ea3a5235.png"></a>

# ğŸ’¡

é¦–å…ˆè¦ä½“ä¼šåˆ°ä¸€ä»¶äº‹æƒ…ï¼Œæ€»æ­¥æ•°ä¸ä¼šè¶…è¿‡ 256 ï¼ˆæ„Ÿæ€§ä¸€ä¸‹  
  
è¿™ä¸ªè‚¯å®šæ˜¯è¦ç”¨ BFS çš„  
ç¡¬ç€å¤´çš®ç›´çº¿æœå¤ªä¼¤äº†  
æ¯ä¸€æ­¥çš„çŸ©é˜µåˆ¤æ–­ä¹Ÿå¾ˆä¼¤  
ä½†æ˜¯çŸ©é˜µä¸å¤§ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥å‹æˆä¸€è¡Œæ•°ï¼Œç”¨è¿™ä¸ªæ•°åˆ¤ç›¸ä¸ç›¸ç­‰å°±å¾ˆå¥½  
  
å¯¹äºæ¢ä½ï¼Œæˆ‘ä»¬æšä¸¾1åˆ°16ä¸ºè¿™è¡Œæ•°çš„ç¬¬å‡ ä½ï¼Œå¯¹è¿™äº›æ•°æ‹†åˆ†æˆçŸ©é˜µåæ ‡  
ä»è€Œå¯ä»¥å¾—å‡ºç›¸é‚»çš„åæ ‡ï¼Œè¦æ¢çš„ç›¸é‚»åæ ‡ä¹Ÿå¯ä»¥å˜æˆæ•°ä½  

```cpp
inline pair<int, int> NumToPos ( int x ) {
        return {(x - 1) / 4 + 1, (x - 1) % 4 + 1};
}
inline int PosToNum ( int x, int y ) {
        return (x - 1) * 4 + y;
}
```

äº¤æ¢è¿™ä¸¤ä¸ªæ•°ä½å³å¯  

```cpp
inline ll new_Swap ( ll x, int i, int j ) {
        ll a = x % ksm(10, i) / ksm(10, i - 1);
        ll b = x % ksm(10, j) / ksm(10, j - 1);
        if ( a != b ) {
                if ( a ) x -= ksm(10, i - 1), x += ksm(10, j - 1);
                else     x -= ksm(10, j - 1), x += ksm(10, i - 1);
        }
        return x;
}
```

ç„¶åå¯¹æ¯ä¸€ä¸ªæ•°å­˜ä¸€ä¸ªè®°å½•ä¸é‡å¤æœç´¢åˆ«çš„ä¹Ÿå°±æ˜¯æ™®é€šçš„BFSäº†    

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >

```cpp
const int mxstp = 256;
const int N = 4;

struct pth {
        int a, b, c, d;
};
struct node {
        ll val;
        int stp;
        vector<pth> p;

} tmp, tgt;


inline ll ksm ( ll a, ll b ) { ll res = 1; while ( b > 0 ) { if ( b & 1 ) res = res * a; a = a * a; b >>= 1; } return res; }
inline ll new_Swap ( ll x, int i, int j ) {
        ll a = x % ksm(10, i) / ksm(10, i - 1);
        ll b = x % ksm(10, j) / ksm(10, j - 1);
        if ( a != b ) {
                if ( a ) x -= ksm(10, i - 1), x += ksm(10, j - 1);
                else     x -= ksm(10, j - 1), x += ksm(10, i - 1);
        }
        return x;
}
inline pair<int, int> NumToPos ( int x ) {
        return {(x - 1) / 4 + 1, (x - 1) % 4 + 1};
}
inline int PosToNum ( int x, int y ) {
        return (x - 1) * 4 + y;
}

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

map<ll, bool> vis;
inline void BFS () {
        queue<node> que;
        que.push(tmp);

        while ( que.size() ) {
                node cur = que.front(); que.pop();
                if ( cur.val == tgt.val ) {
                        cout << cur.stp << endl;
                        for ( int i = 0; i < cur.p.size(); i ++ ) cout << cur.p[i].a << cur.p[i].b << cur.p[i].c << cur.p[i].d << endl;
                        cout << endl;
                        exit(0);
                }
                if ( vis[cur.val] || cur.stp > 256 ) continue; vis[cur.val] = 1;

                for ( int np = 1; np <= 16; np ++ ) {
                        int x = NumToPos(np).first, y = NumToPos(np).second;
                        for ( int i = 0; i < 4; i ++ ) {
                                int nxtx = x + dx[i], nxty = y + dy[i];
                                if ( nxtx >= 1 && nxtx <= 4 && nxty >= 1 && nxty <= 4 ) {
                                        int num = PosToNum(nxtx, nxty);

                                        cur.p.push_back({x, y, nxtx, nxty});
                                        cur.stp ++;
                                        cur.val = new_Swap ( cur.val, np, num );
                                        que.push(cur);
                                        cur.val = new_Swap ( cur.val, np, num );
                                        cur.stp --;
                                        cur.p.pop_back();
                                }
                        }
                }
        }

}

int main () {
        ios::sync_with_stdio(false);

        string s1, s2;
        for ( int i = 0; i < 4; i ++ ) {
                string ss; cin >> ss;
                s1 += ss;
        }
        for ( int i = 0; i < 4; i ++ ) {
                string ss; cin >> ss;
                s2 += ss;
        }
        reverse(s1.begin(), s1.end());
        reverse(s2.begin(), s2.end());

        tmp.val = stoll ( s1 );
        tgt.val = stoll ( s2 );

        BFS();
}
```
