# 🔗

<a href="https://www.luogu.com.cn/problem/P1225"><img src="https://img-blog.csdnimg.cn/eafed431a13b40aab40c6f42ea3a5235.png"></a>

# 💡

首先要体会到一件事情，总步数不会超过 256 （感性一下  
  
这个肯定是要用 BFS 的  
硬着头皮直线搜太伤了  
每一步的矩阵判断也很伤  
但是矩阵不大，我们完全可以压成一行数，用这个数判相不相等就很好  
  
对于换位，我们枚举1到16为这行数的第几位，对这些数拆分成矩阵坐标  
从而可以得出相邻的坐标，要换的相邻坐标也可以变成数位  

```cpp
inline pair<int, int> NumToPos ( int x ) {
        return {(x - 1) / 4 + 1, (x - 1) % 4 + 1};
}
inline int PosToNum ( int x, int y ) {
        return (x - 1) * 4 + y;
}
```

交换这两个数位即可  

```cpp
inline ll new_Swap ( ll x, int i, int j ) {
        ll a = x % ksm(10, i) / ksm(10, i - 1);
        ll b = x % ksm(10, j) / ksm(10, j - 1);
        if ( a != b ) {
                if ( a ) x -= ksm(10, i - 1), x += ksm(10, j - 1);
                else     x -= ksm(10, j - 1), x += ksm(10, i - 1);
        }
        return x;
}
```

然后对每一个数存一个记录不重复搜索别的也就是普通的BFS了    

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >

```cpp
const int mxstp = 256;
const int N = 4;

struct pth {
        int a, b, c, d;
};
struct node {
        ll val;
        int stp;
        vector<pth> p;

} tmp, tgt;


inline ll ksm ( ll a, ll b ) { ll res = 1; while ( b > 0 ) { if ( b & 1 ) res = res * a; a = a * a; b >>= 1; } return res; }
inline ll new_Swap ( ll x, int i, int j ) {
        ll a = x % ksm(10, i) / ksm(10, i - 1);
        ll b = x % ksm(10, j) / ksm(10, j - 1);
        if ( a != b ) {
                if ( a ) x -= ksm(10, i - 1), x += ksm(10, j - 1);
                else     x -= ksm(10, j - 1), x += ksm(10, i - 1);
        }
        return x;
}
inline pair<int, int> NumToPos ( int x ) {
        return {(x - 1) / 4 + 1, (x - 1) % 4 + 1};
}
inline int PosToNum ( int x, int y ) {
        return (x - 1) * 4 + y;
}

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

map<ll, bool> vis;
inline void BFS () {
        queue<node> que;
        que.push(tmp);

        while ( que.size() ) {
                node cur = que.front(); que.pop();
                if ( cur.val == tgt.val ) {
                        cout << cur.stp << endl;
                        for ( int i = 0; i < cur.p.size(); i ++ ) cout << cur.p[i].a << cur.p[i].b << cur.p[i].c << cur.p[i].d << endl;
                        cout << endl;
                        exit(0);
                }
                if ( vis[cur.val] || cur.stp > 256 ) continue; vis[cur.val] = 1;

                for ( int np = 1; np <= 16; np ++ ) {
                        int x = NumToPos(np).first, y = NumToPos(np).second;
                        for ( int i = 0; i < 4; i ++ ) {
                                int nxtx = x + dx[i], nxty = y + dy[i];
                                if ( nxtx >= 1 && nxtx <= 4 && nxty >= 1 && nxty <= 4 ) {
                                        int num = PosToNum(nxtx, nxty);

                                        cur.p.push_back({x, y, nxtx, nxty});
                                        cur.stp ++;
                                        cur.val = new_Swap ( cur.val, np, num );
                                        que.push(cur);
                                        cur.val = new_Swap ( cur.val, np, num );
                                        cur.stp --;
                                        cur.p.pop_back();
                                }
                        }
                }
        }

}

int main () {
        ios::sync_with_stdio(false);

        string s1, s2;
        for ( int i = 0; i < 4; i ++ ) {
                string ss; cin >> ss;
                s1 += ss;
        }
        for ( int i = 0; i < 4; i ++ ) {
                string ss; cin >> ss;
                s2 += ss;
        }
        reverse(s1.begin(), s1.end());
        reverse(s2.begin(), s2.end());

        tmp.val = stoll ( s1 );
        tgt.val = stoll ( s2 );

        BFS();
}
```
