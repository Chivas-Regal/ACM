# 🔗
<a href="https://www.luogu.com.cn/problem/P1132"><img src="https://i.loli.net/2021/11/08/9ynElPS8fCRkUbH.png"></a>

# 💡
一看  <img src="https://latex.codecogs.com/svg.image?\inline&space;s<10^5" title="\inline s<10^5" /> ，最多  <img src="https://latex.codecogs.com/svg.image?\inline&space;5" title="\inline 5" /> 位，那时间最多也就  <img src="https://latex.codecogs.com/svg.image?\inline&space;9^5" title="\inline 9^5" /> ，直接暴力搜然后标记  
我们发现如果一个串可以更快得到，那么它之后的所有转移出来的串都应该被更新，所以我们用  <img src="https://latex.codecogs.com/svg.image?\inline&space;bfs" title="\inline bfs" />  

对给定的串，把它能变成的所有串都标记下来并存一下要变的次数  
如果这个串搜过了就` continue`掉  
  
要注意的是： 
交换要够两个数字  
插入要够两个数字  
删除要够一个数字  

这样的话，到最后我们查数的时候看看这个数有没有被标记即可  
标记的话输出记录的次数，否则  <img src="https://latex.codecogs.com/svg.image?\inline&space;-1" title="\inline -1" />    

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
map<string, int> vis, res;
string wanna;
string s; 
struct node {
        string s;
        int num;
};
inline void bfs () {
        queue<node> que; que.push({s, 0});
        while ( que.size() ) {
                node nd = que.front(); que.pop();
                string x = nd.s; 
                if ( vis[x] ) continue; vis[x] = 1;
                res[x] = nd.num;
                // 1.
                if ( x.size() )
                for ( int i = 0; i < x.size(); i ++ ) 
                        for ( int j = i + 1; j < x.size(); j ++ )
                                swap ( x[i], x[j] ),
                                que.push({x, nd.num + 1}),
                                swap ( x[i], x[j] );
                // 2.
                if ( x.size() )
                for ( int i = 0; i < x.size(); i ++ ) {
                        string tmp; tmp += x[i];
                        x.erase(i, 1);
                        que.push({x, nd.num + 1});
                        x.insert(i, tmp);
                }
                //3.
                if ( x.size() > 1 && x.size () + 1 <= s.size() )
                for ( int i = 0; i < x.size() - 1; i ++ ) {
                        for ( char c = x[i] + 1; c <= x[i + 1] - 1; c ++ ) {
                                string tmp; tmp += c;
                                x.insert(i + 1, tmp);
                                que.push({x, nd.num + 1});
                                x.erase(i + 1, 1);
                        }
                }
        }
}

int main () {
        ios::sync_with_stdio(false);
        cin >> s;
        bfs ();
        int m; cin >> m;
        while ( m -- ) {
                cin >> wanna;
                if ( !res.count(wanna) ) cout << "-1" << endl;
                else                     cout << res[wanna] << endl;
        }
}
```
