# 🔗
<a href="https://www.luogu.com.cn/problem/P1127"><img src="https://i.loli.net/2021/11/15/VW5bIh9EFe4RArd.png"></a>

# 💡
看到这道题第一反应应该是要想到搜索的  
每一个词后面选择性接词  
排个序，如果接到n个词的话第一次就一定是解，输出  
我们预处理出来以每个字母开头的字符串集合  
  
DFS，然后发现TLE两个点  
考虑优化  
看一下有无解的关系   
如果一个字母作为首字母的次数小于作为尾字母次数-1，一定不行   
如果一个字母作为首字母的数量是作为尾字母的数量+1  
那么这个字母必定要作为词链首字母  
如果这样的字母出现多于一个的话就一定不行，冲突了  
如果是一个的话就遍历这一个就行了  
如果没有的话就说明成环，每一个跑一遍就行了  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
vector<int> chr[30];
int n;
string s[1100];

int vis[1100];
int asBeg[30];
int asEnd[30];

inline void dfs ( vector<int> id ) {
        if ( id.size() == n ) {
                for ( int i = 0; i < id.size(); i ++ ) {
                        if ( i ) cout << ".";
                        cout << s[id[i]];
                }
                exit(0);
        }

        for ( int i = 0; i < chr[s[id.back()].back() - 'a'].size(); i ++ ) {
                if ( !vis[chr[s[id.back()].back() - 'a'][i]] ) {
                        vis[chr[s[id.back()].back() - 'a'][i]] = 1;
                        id.push_back(chr[s[id.back()].back() - 'a'][i]); dfs ( id ); id.pop_back();
                        vis[chr[s[id.back()].back() - 'a'][i]] = 0;
                }
        }
}


int main () {
        cin >> n;
        for ( int i = 0; i < n; i ++ ) 
                cin >> s[i],
                asBeg[s[i][0] - 'a'] ++,
                asEnd[s[i].back() - 'a'] ++;
        sort ( s, s + n );
        for ( int i = 0; i < n; i ++ )
                chr[s[i][0] - 'a'].push_back(i);
        
        int num_char_can_first = 0;
        char char_can_first;
        for ( char i = 'a'; i <= 'z'; i ++ ) {
                if ( asBeg[i - 'a'] == asEnd[i - 'a'] + 1 ) 
                        num_char_can_first ++,
                        char_can_first = i;
                if ( asBeg[i - 'a'] < asEnd[i - 'a'] - 1 ) { cout << "***" << endl; exit(0); }
        }

        if ( num_char_can_first > 1 ) {
                cout << "***" << endl;
        } else if ( num_char_can_first == 1 ) {
                for ( int i = 0; i < n; i ++ ) {
                        if ( s[i][0] == char_can_first ) {
                                vis[i] = 1;
                                dfs ( {i} );
                                vis[i] = 0;
                        }
                }
        } else {
                for ( int i = 0; i < n; i ++ ) {
                        vis[i] = 1;
                        dfs ( {i} );
                        vis[i] = 0;
                }
        }
        cout << "***" << endl;
}
```
