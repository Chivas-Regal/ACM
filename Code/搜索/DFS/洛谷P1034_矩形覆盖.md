# 🔗
<a href="https://www.luogu.com.cn/problem/P1034"><img src="https://i.loli.net/2021/11/08/zkj1RuNLO2AfIS6.png"></a>

# 💡
我们必然是想将所有的点分为连续的  <img src="https://latex.codecogs.com/svg.image?\inline&space;k" title="\inline k" />  块  
即要么双关键字  <img src="https://latex.codecogs.com/svg.image?\inline&space;(x,y)" title="\inline (x,y)" /> 要么  <img src="https://latex.codecogs.com/svg.image?\inline&space;(y,x)" title="\inline (y,x)" />   
单一种不行是有可能相临的两个  <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" /> (或  <img src="https://latex.codecogs.com/svg.image?\inline&space;y" title="\inline y" /> ) 之间的 <img src="https://latex.codecogs.com/svg.image?\inline&space;y" title="\inline y" /> (或  <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" /> )差的很大，这样的话就排一种其实也是选择得相对分散了  
我们对这两个方式排过序后，每种都计算一下在这种排序方案下我们能得到的最小值，进行比较一下即可  
  
至于怎么算最小值，我们可以枚举最多  <img src="https://latex.codecogs.com/svg.image?\inline&space;k-1" title="\inline k-1" />  个断点  
以断点进行分割计算每一块的最大最小  <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline x" /> 和最大最小  <img src="https://latex.codecogs.com/svg.image?\inline&space;y" title="\inline y" /> ，他们差值的乘积就是这一个矩形的面积

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N = 100;
int n, k;
struct Point {
        int x, y;
} pt[N];

inline void DFS ( vector<int> paus, int num, int &res ) { // 断点，我们需要的断点数量，传递答案
        if ( paus.size() == num ) {
                int cur = 0;
                paus.push_back(n);
                for ( int k = 1; k < paus.size(); k ++ ) {
                        int maxX = 0, maxY = 0, minX = 0x3f3f3f3f, minY = 0x3f3f3f3f;
                        for ( int i = paus[k - 1] + 1; i <= paus[k]; i ++ ) {
                                maxX = max(maxX, pt[i].x), minX = min(minX, pt[i].x),
                                maxY = max(maxY, pt[i].y), minY = min(minY, pt[i].y);
                        }
                        cur += (maxX - minX) * (maxY - minY);
                }
                res = min(res, cur);
                return;
        }
        for ( int i = paus.back() + 1; i < n; i ++ ) {
                paus.push_back(i); 
                DFS ( paus, num, res );
                paus.pop_back();
        }
}

int main () {
        int res = 0x3f3f3f3f;
        cin >> n >> k;
        for ( int i = 1; i <= n; i ++ ) cin >> pt[i].x >> pt[i].y;
        sort ( pt + 1, pt + 1 + n, [&]( Point a, Point b ) {
                if ( a.x != b.x ) return a.x < b.x;
                return a.y < b.y;
        } );
        for ( int i = 1; i <= k; i ++ ) {
                DFS({0}, i, res);
        }
        sort ( pt + 1, pt + 1 + n, [&]( Point a, Point b ) {
                if ( a.y != b.y ) return a.y < b.y;
                return a.x < b.x;
        } );
        for ( int i = 1; i <= k; i ++ ) {
                DFS({0}, i, res);
        }
        cout << res << endl;
}

```
