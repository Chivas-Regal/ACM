# 🔗
<a href="https://www.luogu.com.cn/problem/P1041"><img src="https://i.loli.net/2021/11/08/7R9mzdfIFSvkqEl.png"></a>

# 💡
感性地理解一下，从根开始传播，每一次只能取一个点隔断  
那其实就是，每一次选择一个深度的一个点进行隔断  
  
我们可以暴力搜一下，对于一个深度，我们选择哪些点进行隔断  
当然如果这个点上面有祖先已经被隔断了，那么这个点是安全的，就不需要进行隔断  
我们其实要算的就是最后不安全的点数的最小值  
  
我们先预处理出深度数组  
然后  <img src="https://latex.codecogs.com/svg.image?\inline&space;Dfs" title="\inline Dfs" />  每次下潜一个深度  
在这个深度下枚举我们要隔断哪个不安全的点  
隔断后这个点的子树全部变为安全（通过又一种深搜  <img src="https://latex.codecogs.com/svg.image?\inline&space;Save" title="\inline Save" /> 实现，当然我们要回溯一下再变成不安全代表我们不选  
每一次进行隔断都会安全化整个子树，所以我们预处理时也统计一下所有节点的子树大小即可  
  
每次走到最深的点时就维护一下  <img src="https://latex.codecogs.com/svg.image?\inline&space;res" title="\inline res" /> 的最小值

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
int res = 0x3f3f3f3f;

namespace Map {
        const int M = 610;
        int head[M], cnt;
        struct Edge {
                int nxt, to;
        } edge[M];

        inline void add_Edge ( int from, int to ) {
                edge [ ++ cnt ] = { head[from], to };
                head[from] = cnt;
        }
} using namespace Map;

const int N = 310;
namespace TreeInformation {
        int dep[N], fa[N], mxdep, sz[N];
        inline void dfs ( int x, int fath ) {
                fa[x] = fath; dep[x] = dep[fath] + 1; sz[x] = 1;
                mxdep = max ( mxdep, dep[x] );
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fath ) continue;
                        dfs ( to, x );
                        sz[x] += sz[to];
                }
        }
        int saf[N];
        inline void Save ( int x, int is ) {
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fa[x] ) continue;
                        saf[to] = is;
                        Save ( to, is );
                }
        }
} using namespace TreeInformation;


vector<int> vec[N]; // vec[i]表示深度为i的点集合
int n, m;
map<int, int> tmp;

inline void Solve ( int d, int num ) {
        bool flag = false;
        if ( d > mxdep ) { res = min(res, num); return ;}
        for ( auto id : vec[d] ) {
                if ( saf[id] ) continue;
                saf[id] = 1; Save ( id, 1 );
                Solve ( d + 1, num - sz[id] );
                saf[id] = 0; Save ( id, 0 );
                flag = true;
        }
        if ( !flag ) res = min ( res, num );
}

int main () {
        ios::sync_with_stdio(false);
        cin >> n >> m;
        for ( int i = 0, x, y; i < m; i ++ ) {
                cin >> x >> y;
                add_Edge ( x, y );
                add_Edge ( y, x );
        }
        dfs ( 1, 1 );
        for ( int i = 1; i <= n; i ++ ) vec[dep[i]].push_back(i);
        Solve ( 2, n );
        cout << res << endl;       
}
```
