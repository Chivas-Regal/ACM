# ğŸ”—
<a href="https://www.luogu.com.cn/problem/P1041"><img src="https://i.loli.net/2021/11/08/7R9mzdfIFSvkqEl.png"></a>

# ğŸ’¡
æ„Ÿæ€§åœ°ç†è§£ä¸€ä¸‹ï¼Œä»æ ¹å¼€å§‹ä¼ æ’­ï¼Œæ¯ä¸€æ¬¡åªèƒ½å–ä¸€ä¸ªç‚¹éš”æ–­  
é‚£å…¶å®å°±æ˜¯ï¼Œæ¯ä¸€æ¬¡é€‰æ‹©ä¸€ä¸ªæ·±åº¦çš„ä¸€ä¸ªç‚¹è¿›è¡Œéš”æ–­  
  
æˆ‘ä»¬å¯ä»¥æš´åŠ›æœä¸€ä¸‹ï¼Œå¯¹äºä¸€ä¸ªæ·±åº¦ï¼Œæˆ‘ä»¬é€‰æ‹©å“ªäº›ç‚¹è¿›è¡Œéš”æ–­  
å½“ç„¶å¦‚æœè¿™ä¸ªç‚¹ä¸Šé¢æœ‰ç¥–å…ˆå·²ç»è¢«éš”æ–­äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªç‚¹æ˜¯å®‰å…¨çš„ï¼Œå°±ä¸éœ€è¦è¿›è¡Œéš”æ–­  
æˆ‘ä»¬å…¶å®è¦ç®—çš„å°±æ˜¯æœ€åä¸å®‰å…¨çš„ç‚¹æ•°çš„æœ€å°å€¼  
  
æˆ‘ä»¬å…ˆé¢„å¤„ç†å‡ºæ·±åº¦æ•°ç»„  
ç„¶å  <img src="https://latex.codecogs.com/svg.image?\inline&space;Dfs" title="\inline Dfs" />  æ¯æ¬¡ä¸‹æ½œä¸€ä¸ªæ·±åº¦  
åœ¨è¿™ä¸ªæ·±åº¦ä¸‹æšä¸¾æˆ‘ä»¬è¦éš”æ–­å“ªä¸ªä¸å®‰å…¨çš„ç‚¹  
éš”æ–­åè¿™ä¸ªç‚¹çš„å­æ ‘å…¨éƒ¨å˜ä¸ºå®‰å…¨ï¼ˆé€šè¿‡åˆä¸€ç§æ·±æœ  <img src="https://latex.codecogs.com/svg.image?\inline&space;Save" title="\inline Save" /> å®ç°ï¼Œå½“ç„¶æˆ‘ä»¬è¦å›æº¯ä¸€ä¸‹å†å˜æˆä¸å®‰å…¨ä»£è¡¨æˆ‘ä»¬ä¸é€‰  
æ¯ä¸€æ¬¡è¿›è¡Œéš”æ–­éƒ½ä¼šå®‰å…¨åŒ–æ•´ä¸ªå­æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬é¢„å¤„ç†æ—¶ä¹Ÿç»Ÿè®¡ä¸€ä¸‹æ‰€æœ‰èŠ‚ç‚¹çš„å­æ ‘å¤§å°å³å¯  
  
æ¯æ¬¡èµ°åˆ°æœ€æ·±çš„ç‚¹æ—¶å°±ç»´æŠ¤ä¸€ä¸‹  <img src="https://latex.codecogs.com/svg.image?\inline&space;res" title="\inline res" /> çš„æœ€å°å€¼

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
int res = 0x3f3f3f3f;

namespace Map {
        const int M = 610;
        int head[M], cnt;
        struct Edge {
                int nxt, to;
        } edge[M];

        inline void add_Edge ( int from, int to ) {
                edge [ ++ cnt ] = { head[from], to };
                head[from] = cnt;
        }
} using namespace Map;

const int N = 310;
namespace TreeInformation {
        int dep[N], fa[N], mxdep, sz[N];
        inline void dfs ( int x, int fath ) {
                fa[x] = fath; dep[x] = dep[fath] + 1; sz[x] = 1;
                mxdep = max ( mxdep, dep[x] );
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fath ) continue;
                        dfs ( to, x );
                        sz[x] += sz[to];
                }
        }
        int saf[N];
        inline void Save ( int x, int is ) {
                for ( int i = head[x]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( to == fa[x] ) continue;
                        saf[to] = is;
                        Save ( to, is );
                }
        }
} using namespace TreeInformation;


vector<int> vec[N]; // vec[i]è¡¨ç¤ºæ·±åº¦ä¸ºiçš„ç‚¹é›†åˆ
int n, m;
map<int, int> tmp;

inline void Solve ( int d, int num ) {
        bool flag = false;
        if ( d > mxdep ) { res = min(res, num); return ;}
        for ( auto id : vec[d] ) {
                if ( saf[id] ) continue;
                saf[id] = 1; Save ( id, 1 );
                Solve ( d + 1, num - sz[id] );
                saf[id] = 0; Save ( id, 0 );
                flag = true;
        }
        if ( !flag ) res = min ( res, num );
}

int main () {
        ios::sync_with_stdio(false);
        cin >> n >> m;
        for ( int i = 0, x, y; i < m; i ++ ) {
                cin >> x >> y;
                add_Edge ( x, y );
                add_Edge ( y, x );
        }
        dfs ( 1, 1 );
        for ( int i = 1; i <= n; i ++ ) vec[dep[i]].push_back(i);
        Solve ( 2, n );
        cout << res << endl;       
}
```
