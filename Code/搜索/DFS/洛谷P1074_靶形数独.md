# 🔗
<a href="https://www.luogu.com.cn/problem/P1074"><img src="https://i.loli.net/2021/11/11/LxriZwV6NmY9oua.png"></a>

# 💡
大小很小，多枝多可能  
于是直接开爆搜  
  
仔细一想约束条件就有很多了  
比如同行同列不能出现两个相同的  
同九宫格不能出现两个相同的  
  
那么我们开一个行数组列数组块数组  
记录一下每块、每行、每列是否有  <img src="https://latex.codecogs.com/svg.image?\inline&space;i" title="\inline i" />   
这样的话就是搜索的结果，剪枝剪下去也不会非常大  
而且还能保证最后出来的都是完成的数独    

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <vector>

#define ll long long

using namespace std;

const int N = 15;
int a[N][N];
int res = -1;

bool row[N][N], col[N][N], blk[N][N]; // ()[i][j] 第 i (行、列、块) 是否有 j

inline int which ( int x, int y ) { // 第几块
        if ( x < 3 ) {
                if ( y < 3 ) return 1;
                if ( y < 6 ) return 2;
                if ( y < 9 ) return 3;
        } else if ( x < 6 ) {
                if ( y < 3 ) return 4;
                if ( y < 6 ) return 5;
                if ( y < 9 ) return 6;
        } else {
                if ( y < 3 ) return 7;
                if ( y < 6 ) return 8;
                if ( y < 9 ) return 9;
        }
}

inline void DFS ( int i, int j ) {
        if ( j >= 9 ) {
                int cur = 0;
                for ( int x = 0; x < 9; x ++ ) {
                        for ( int y = 0; y < 9; y ++ ) {
                                if      ( x >= 4 && x <= 4 && y >= 4 && y <= 4 ) cur += a[x][y] * 10;
                                else if ( x >= 3 && x <= 5 && y >= 3 && y <= 5 ) cur += a[x][y] * 9;
                                else if ( x >= 2 && x <= 6 && y >= 2 && y <= 6 ) cur += a[x][y] * 8;
                                else if ( x >= 1 && x <= 7 && y >= 1 && y <= 7 ) cur += a[x][y] * 7;
                                else                                             cur += a[x][y] * 6;
                        }
                }

                res = max ( res, cur );
                return;
        }

        int nxtj = j + (i + 1) / 9; // 下一个的列
        int nxti = (i + 1) % 9;     // 下一个的行
 
        if ( a[i][j] ) DFS ( nxti, nxtj ); // 预订了
        else {
                for ( int num = 9; num >= 1; num -- ) if ( !row[i][num] && !col[j][num] && !blk[which(i, j)][num] ) { // 都满足就搜下去
                        row[i][num] = col[j][num] = blk[which(i, j)][num] = 1;
                        a[i][j] = num; DFS ( nxti, nxtj ); a[i][j] = 0;
                        row[i][num] = col[j][num] = blk[which(i, j)][num] = 0;          
                }
        }
}

int main () {
        for ( int i = 0; i < 9; i ++ ) for ( int j = 0; j < 9; j ++ ) {
                scanf("%d", &a[i][j]);
                if ( a[i][j] ) 
                        row[i][a[i][j]] = col[j][a[i][j]] = blk[which(i, j)][a[i][j]] = 1;
        }
        DFS ( 0, 0 );
        printf("%d\n", res);
        return 0;
}
```
