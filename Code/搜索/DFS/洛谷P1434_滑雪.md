# 🔗
<a href="https://www.luogu.com.cn/problem/P1434"><img src="https://i.loli.net/2021/10/23/hAd9QENCRYW4mB5.png"></a>

# 💡
对于每个点，在搜索的时候记录一下它能到达的最远距离  
然后每一次搜索都是最优子问题的汇聚过程  
每一个点对每一个可以转移的连接点进行连接，这些点的dfs()+1就是当前点的最优子问题之一  
对每一个点都dfs一边即可  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
int n, m;
int a[110][110];
int dp[110][110];
int dx[4] = {0, 0, -1, 1};
int dy[4] = {1, -1, 0, 0};
int res = 0;

inline int dfs ( int x, int y ) {
        if ( dp[x][y] > 1 ) return dp[x][y];
        for ( int i = 0; i < 4; i ++ ) {
                if ( x + dx[i] >= 0 && x + dx[i] < n && y + dy[i] >= 0 && y + dy[i] < m && a[x + dx[i]][y + dy[i]] < a[x][y] ) 
                        dp[x][y] = max(dp[x][y], dfs ( x + dx[i], y + dy[i] ) + 1);
        }
        return dp[x][y];
}

int main () {
        ios::sync_with_stdio(false);
        cin >> n >> m;
        for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) cin >> a[i][j], dp[i][j] = 1;
        for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) res = max ( res, dfs ( i, j ) );
        cout << res << endl;
}
```
