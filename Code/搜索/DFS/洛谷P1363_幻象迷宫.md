# 🔗
<a href="https://www.luogu.com.cn/problem/P1363"><img src="https://i.loli.net/2021/10/23/utags5MohH7nNpw.png"></a>

# 💡
对于一个点，如果在两张图中且两次到达这个点，那么这个图就可以彻底连通  
那么我们用一个vis数组来维护一个点是否被不折回跑地两次到达  
那么就是两个变量控制不取模的原始位置，一个变量控制是否走过  
如果一个取模后的位置被走过且另外两个变量有一个与当前位置不同，就代表不折回跑地到达了两次  
遍历就行了  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
int n, m;
string s[2000];
int flag = 0;
int dx[4] = {0, 0, -1, 1};
int dy[4] = {1, -1, 0, 0};
int vis[2000][2000][3];

inline void dfs ( int x, int y, int X, int Y ) {
        if ( s[x][y] == '#' ) return;
        if ( flag ) return;
        if ( vis[x][y][0] && ( vis[x][y][1] != X || vis[x][y][2] != Y ) ) {flag = 1; return;} // 走过模坐标但是有一个老坐标不和新坐标相等

        vis[x][y][0] = 1, vis[x][y][1] = X, vis[x][y][2] = Y; // 记录一下新坐标

        for ( int i = 0; i < 4; i ++ ) {
                int curx = (x + dx[i] + n) % n, cury = (y + dy[i] + m) % m;
                int curX = X + dx[i], curY = Y + dy[i];
                if ( vis[curx][cury][1] != curX || vis[curx][cury][2] != curY || !vis[curx][cury][0] ) // 三个变量控制是不是走的是走过的点
                        dfs ( curx, cury, curX, curY );
        }
}

inline void Solve () {
        flag = 0; memset ( vis, 0, sizeof vis );
        int sttx, stty;
        for ( int i = 0; i < n; i ++ ) {
                cin >> s[i];
                for ( int j = 0; j < m; j ++ ) {
                        if ( s[i][j] == 'S' ) sttx = i, stty = j;
                }
        }
        dfs ( sttx, stty, sttx, stty );
        if ( flag ) cout << "Yes" << endl;
        else        cout << "No" << endl;
}

int main () {
        while ( cin >> n >> m ) {
                Solve ();
        }
}
```
