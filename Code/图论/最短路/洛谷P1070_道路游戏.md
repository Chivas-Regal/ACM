# 🔗
<a href="https://www.luogu.com.cn/problem/P1070"><img src="https://i.loli.net/2021/11/09/mv7uyJrnicTWbqR.png"></a>

# 💡
想不出来去看了题解，一堆单调队列(2021/11/09: 没学过)题解，然后就看到了一个题解说用SPFA能过  
~~真是小刀划屁股给👴开了眼~~  
  
然后想了半天发现雀食是这么回事  
这是一个要转移最优解的问题  
而每一次转移都是从一个已有的优解转移出一个新的优解，这份转移价值就是你在这个时间哪个工场买了机器人跑几次  
可以发现时间与时间之间还有制约关系，就是你a时间买了个机器人让它跑b次那么你一定会在a+b时间继续抉择  
就相当于a时间和a+b时间连了个边  
  
（那不就最短路更新了？  
由于会出现负权，我们要使用  <img src="https://latex.codecogs.com/svg.image?\inline&space;SPFA" title="\inline SPFA" />   
我们使用基本的bfs，队内塞时间点，每次对一个时间点枚举一下此时选择哪个工厂造使用多长时间的机器人  
由于会推到另一个时间点，我们设置类似于最段路的best数组，和是否在队内的inq数组  
对下一个时间点本身的best和它是否在队内决定吧更不更新和入不入队  
  
在时间p和总时间m和spfa的优化下不会太长时间  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <queue>
#include <cstring>


#define ll long long

using namespace std;

const int N = 1e3 + 10;
const int M = 1e3 + 10;
int n, m, p;
int pth[N][N];
int dty[N];

int best[M]; // best[i]: i时刻的最多钱数
bool inq[M]; // inq[i] : i时刻在队里面没有

int main () {
        ios::sync_with_stdio(false);
        memset ( best, -0x3f3f3f3f, sizeof best );
        cin >> n >> m >> p;
        for ( int i = 0; i < n; i ++ ) for ( int j = 0; j < m; j ++ ) cin >> pth[i][j];
        for ( int i = 0; i < n; i ++ ) cin >> dty[i];

        int res = -0x3f3f3f3f;
        queue<int> que; // 存的是时间
        que.push(0); best[0] = 0;
        while ( que.size() ) {
                int cur_time = que.front(); que.pop(); inq[cur_time] = false; // 当前时间
                res = max ( res, best[cur_time] );
                for ( int dtyid = 0; dtyid < n; dtyid ++ ) {                                // 选择哪个工厂买机器人
                        int getmoney = -dty[dtyid];                                         // 获得钱数
                        for ( int sttm = 1; sttm <= p && sttm + cur_time <= m; sttm ++ ) {  // 设置多长时间
                                getmoney += pth[(dtyid + sttm - 1) % n][(cur_time + sttm - 1) % m]; 

                                int nxt_time = cur_time + sttm;             // 新产生的时间
                                int nxt_money = best[cur_time] + getmoney;  // 新产生的钱数
                                if ( best[nxt_time] < nxt_money ) {         // 有更优的方案
                                        best[nxt_time] = nxt_money;         // 更新一下
                                        if ( !inq[nxt_time] )               // 如果不在队列里面那么更新不起递推作用，要放进去
                                                que.push(nxt_time),
                                                inq[nxt_time] = true;
                                }
                        }
                }
        }
        cout << res << endl;
}
```
