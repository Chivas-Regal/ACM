# 🔗
<a href="https://www.luogu.com.cn/problem/P1119"><img src="https://i.loli.net/2021/11/13/pUWGAtQkuLPnavR.png"></a>

# 💡
这个题就是最短路加上点更新  
由于问我们的点比较随机加上点数比较少  
  
考虑到  <img src="https://latex.codecogs.com/svg.image?\inline&space;Floyd" title="\inline Floyd" /> 的更新机制就是以点为中转  
那么我们可以直接使用其  <img src="https://latex.codecogs.com/svg.image?\inline&space;Dp" title="\inline Dp" /> 思想进行更新  
出现一个点时，所有以它为中转的点都可以更新一下看看  
如果问的两个点都不在时间内或者中间无法转移  
那么就输出-1  
否则就是  <img src="https://latex.codecogs.com/svg.image?\inline&space;Floyd" title="\inline Floyd" /> 的那个数组  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N = 1e4 + 10;
int dis[N][N];
int t[N], n, m, q;

vector<int> tims[N]; // tims[i]: 时间i的时候已经建成的村庄集合

int main () {
        cin >> n >> m;
        for ( int i = 0; i < n; i ++ ) cin >> t[i], tims[t[i]].push_back(i);
        for ( int i = 0; i < n; i ++ ) {
                for ( int j = 0; j < n; j ++ ) {
                        if ( i == j ) dis[i][j] = 0;
                        else          dis[i][j] = 0x3f3f3f3f;
                }
        }
        for ( int i = 0; i < m; i ++ ) {
                int a, b, c; cin >> a >> b >> c;
                dis[a][b] = dis[b][a] = c;
        }


        function<void(int)> update = [&]( int x ) { // 点更新
                for ( int i = 0; i < n; i ++ ) {
                        for ( int j = 0; j < n; j ++ ) {
                                if ( dis[i][j] > dis[i][x] + dis[x][j] ) 
                                        dis[i][j] = dis[j][i] = dis[i][x] + dis[x][j];
                        }
                }
        };

        int curtime = 0, q; 
        cin >> q;
        while ( q -- ) {
                int x, y, tm; cin >> x >> y >> tm;
                while ( curtime <= tm ) {
                        for ( auto i : tims[curtime] ) update ( i );
                        curtime ++;
                }
                if ( t[x] > tm || t[y] > tm || dis[x][y] == 0x3f3f3f3f ) cout << "-1" << endl;
                else                                                     cout << dis[x][y] << endl;
        }
}
```
