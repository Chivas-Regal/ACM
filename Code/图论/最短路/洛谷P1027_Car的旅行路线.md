# 🔗
<a href="https://www.luogu.com.cn/problem/P1027"><img src="https://i.loli.net/2021/11/08/jh9RDYaMGVCAg1t.png"></a>

# 💡
其实刚开始想的是一个dp的解法  
想着全排列一下然后从a到b每一个城市四个点由上一个城市四个点跑火车和跑飞机推过来  
想到时间复杂度过不去， <img src="https://latex.codecogs.com/svg.image?\inline&space;O(n\times&space;n!)" title="\inline O(n\times n!)" />   
然后~~这一看不就是个图论吗~~  
建好边然后四个点各跑一次  <img src="https://latex.codecogs.com/svg.image?\inline&space;Dijkstra" title="\inline Dijkstra" />   
从  <img src="https://latex.codecogs.com/svg.image?\inline&space;a" title="\inline a" /> 城市的四个点到  <img src="https://latex.codecogs.com/svg.image?\inline&space;b" title="\inline b" /> 城市的四个点一共  <img src="https://latex.codecogs.com/svg.image?\inline&space;16" title="\inline 16" /> 种走法选最短的就行了...

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const int N = 15;
const int NN = 100;
const int M = 1e6;
const double eps = 1e-9;

struct Contry {
        double x[4], y[4];
        double T;
} cty[N];
int n, a, b;
double t;

namespace Map {
        struct Edge {
                int nxt, to;
                double val;
        } edge[M];
        int head[M], cnt;
        inline void add_Edge ( int from, int to, double val ) {
                edge[ ++ cnt ] = { head[from], to, val };
                head[from] = cnt;
        }
} using namespace Map;

namespace ShortestPath {
        struct node {
                int id;
                double dis;
                inline friend bool operator < (node a, node b) {
                        return a.dis > b.dis;
                }
        };
        double dis[NN]; bool vis[NN];
        inline void Dijkstra ( int id ) {
                for ( int i = 0; i < NN; i ++ ) dis[i] = 0x3f3f3f3f, vis[i] = 0;
                priority_queue<node> pque;
                dis[id] = 0;
                pque.push({id, dis[id]});
                while ( pque.size() ) {
                        node stt = pque.top(); pque.pop();
                        if ( vis[stt.id] ) continue; vis[stt.id] = 1;
                        for ( int i = head[stt.id]; i; i = edge[i].nxt ) {
                                int to = edge[i].to;
                                if ( dis[to] - dis[stt.id] - edge[i].val >= eps ) {
                                        dis[to] = dis[stt.id] + edge[i].val;
                                        pque.push({to, dis[to]});
                                }
                        }
                }
        }
} using namespace ShortestPath;

inline double Dis ( double x1, double y1, double x2, double y2 ) {
        double dirx = x1 - x2;
        double diry = y1 - y2;
        return sqrt ( dirx * dirx + diry * diry );
}

inline void Solve() {
        cin >> n >> t >> a >> b;
        for ( int i = 1; i <= n; i ++ ) {
                cin >> cty[i].x[0] >> cty[i].y[0]; 
                cin >> cty[i].x[1] >> cty[i].y[1]; 
                cin >> cty[i].x[2] >> cty[i].y[2]; 
                double ds01 = (cty[i].x[0] - cty[i].x[1]) * (cty[i].x[0] - cty[i].x[1]) + (cty[i].y[0] - cty[i].y[1]) * (cty[i].y[0] - cty[i].y[1]);
                double ds02 = (cty[i].x[0] - cty[i].x[2]) * (cty[i].x[0] - cty[i].x[2]) + (cty[i].y[0] - cty[i].y[2]) * (cty[i].y[0] - cty[i].y[2]);
                double ds12 = (cty[i].x[2] - cty[i].x[1]) * (cty[i].x[2] - cty[i].x[1]) + (cty[i].y[2] - cty[i].y[1]) * (cty[i].y[2] - cty[i].y[1]);
                if ( ds01 + ds02 == ds12 ) cty[i].x[3] = cty[i].x[1] + cty[i].x[2] - cty[i].x[0], cty[i].y[3] = cty[i].y[1] + cty[i].y[2] - cty[i].y[0];
                if ( ds01 + ds12 == ds02 ) cty[i].x[3] = cty[i].x[0] + cty[i].x[2] - cty[i].x[1], cty[i].y[3] = cty[i].y[0] + cty[i].y[2] - cty[i].y[1];
                if ( ds02 + ds12 == ds01 ) cty[i].x[3] = cty[i].x[0] + cty[i].x[1] - cty[i].x[2], cty[i].y[3] = cty[i].y[0] + cty[i].y[1] - cty[i].y[2];
                cin >> cty[i].T;
        }
        for ( int i = 1; i <= n; i ++ ) {
                for ( int i1 = 0; i1 < 4; i1 ++ ) {
                        for ( int i2 = 0; i2 < 4; i2 ++ ) {
                                if ( i1 == i2 ) continue;
                                add_Edge ( i * 4 + i1, i * 4 + i2, Dis(cty[i].x[i1], cty[i].y[i1], cty[i].x[i2], cty[i].y[i2]) * cty[i].T );
                        }
                }
                for ( int j = 1; j <= n; j ++ ) {
                        if ( i == j ) continue;
                        for ( int ii = 0; ii < 4; ii ++ ) {
                                for ( int jj = 0; jj < 4; jj ++ ) {
                                        add_Edge ( i * 4 + ii, j * 4 + jj, Dis(cty[i].x[ii], cty[i].y[ii], cty[j].x[jj], cty[j].y[jj]) * t );
                                }
                        }
                }
        }
        double res = 0x3f3f3f3f;
        for ( int i = 0; i < 4; i ++ ) {
                Dijkstra(a * 4 + i);
                for ( int j = 0; j < 4; j ++ ) res = min ( res, dis[b * 4 + j] );
        }
        printf("%.1f\n", res);
}

int main () {
        int cass; cin >> cass; while ( cass -- ) Solve ();
}
```
