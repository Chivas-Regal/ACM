# 🔗
<a href="https://www.luogu.com.cn/problem/P4336"><img src="https://user-images.githubusercontent.com/78973908/137636458-da759b5b-92e3-426b-98f9-62b742355442.png"></a>

# 💡
每条公路只能给一个公司构造  
如果多个公司建造这条路  
那么就是我们重复考虑的地方  
重复，计数，可以想到容斥原理  
我们可以二进制枚举一下让哪些公司来建边  
每一次的结果就是这套方案的生成树个数  
  
然后容斥地加减，最后得到每条边一个公司建造的结果  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const ll M = 100;
const ll mod = 1e9 + 7;
ll a[M][M];
ll n, m;

inline void add ( ll x, ll y ) {
        -- a[x][y];
        -- a[y][x];
        ++ a[x][x];
        ++ a[y][y];
}
inline ll Gauss ( ll n ) {
        ll res = 1;
        for ( ll i = 1; i <= n; i ++ ) { // 在(i, i)上进行消元
                for ( ll ii = i + 1; ii <= n; ii ++ ) { // 将(ii, i)变成0
                        while ( a[ii][i] ) {
                                ll d = a[i][i] / a[ii][i];
                                for ( ll j = i; j <= n; j ++ )
                                        a[i][j] = (a[i][j] - (ll)d * a[ii][j] % mod + mod) % mod,
                                                swap ( a[i][j], a[ii][j] );
                                res = -res;
                        }
                }
                res = (ll)res * a[i][i] % mod;
                if ( res == 0 ) return 0;
        }
        return (res % mod + mod) % mod;
}

vector<pair<ll, ll> > vec[M];

int main () {
        cin >> n;
        for ( ll i = 0; i < n - 1; i ++ ) {
                cin >> m;
                for ( ll j = 0, x, y; j < m; j ++ ) {
                        cin >> x >> y;
                        vec[i].push_back({x, y});
                }
        }
        ll res = 0;
        for ( ll num = 0; num < (1ll << (n - 1)); num ++ ) {
                for ( ll i = 0; i < M; i ++ ) for ( ll j = 0; j < M; j ++ ) a[i][j] = 0;
                ll cnt = 0;
                for ( ll i = 0; i < n - 1; i ++ ) {
                        if ( num & (1 << i) ) {
                                cnt ++;
                                for ( auto j : vec[i] ) add(j.first, j.second);
                        }
                }
                if ( (n - cnt) & 1 ) res = (res + Gauss(n - 1)) % mod;
                else res = (res - Gauss( n - 1 ) + mod) % mod;
        }
        cout << res << endl;
        return 0;
}
```
