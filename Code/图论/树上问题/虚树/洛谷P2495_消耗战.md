# ğŸ”—
<a href="https://www.luogu.com.cn/problem/P2495"><img src="https://i.loli.net/2021/10/16/L7D5hCdegkOGptv.png"></a>

# ğŸ’¡
é¦–å…ˆæƒ³åˆ°æ ‘å½¢dpå‘ä¸Šè½¬ç§»  
å¯¹äºiï¼Œå½“å‰å„¿å­æ˜¯toï¼Œé¢„å¤„ç†å‡ºæ¥1åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»minv[i]  
å¦‚æœtoæ˜¯å…³é”®ç‚¹ï¼šdp[i] += minv[i]  
å¦‚æœtoä¸æ˜¯å…³é”®ç‚¹ï¼šdp[i] += min ( minv[i], dp[to] )  
  
è€Œé¢˜ç›®ä¸­è¯¢é—®çš„æ˜¯æ€»å’Œ  
é‚£ä¹ˆæˆ‘ä»¬å…¶å®å°±å¯ä»¥ç®—å‡ºæ¥å½±å“åˆ°çš„ç‚¹å’Œè¾¹çš„dpæœ€ä¼˜è§£  
æœ‰å¾ˆå¤šæ²¡å—åˆ°å½±å“çš„å…¶å®ä¸å¿…è¦è·‘dpï¼Œæ—¶é—´æ‰¿æ‹…ä¸äº†  
å¯¹éœ€è¦çš„è·‘dpï¼Œå¯ä»¥æƒ³åˆ°æ„å»ºä¸€æ£µè™šæ ‘  
å†è™šæ ‘ä¸Šè·‘  
  
å°±å¯¹å…³é”®ç‚¹å’Œäº¤æ±‡ç‚¹å»ºç«‹è™šæ ‘å³å¯  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <map>
#include <vector>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <queue>

#define ll long long
using namespace std;

const int N = 500500;
const int M = 10000;


int n, q, num;

namespace Map {
        struct Edge {
                int nxt, to;
                ll val;
        }edge[N << 1], vedge[N << 1]; // ä¸»æ ‘è¾¹ï¼Œè™šæ ‘è¾¹
        int  head[N << 1],  cnt = 0;  // ä¸»æ ‘æŒ‡é’ˆ
        int vhead[N << 1], vcnt = 0;  // è™šæ ‘æŒ‡é’ˆ
        inline void add_Edge ( int from, int to, ll val ) { // æ·»åŠ ä¸»æ ‘
                edge[ ++ cnt ] = (Edge){ head[from], to, val };
                head[from] = cnt;
        }
        inline void add_vEdge ( int from, int to ) {        // æ·»åŠ è™šæ ‘ 
                vedge[ ++ vcnt ] = (Edge){ vhead[from], to };
                vhead[from] = vcnt;
        }
} using namespace Map;

namespace VirtualTree {
        int dfscnt = 1, dfn[N]; // dfsåº
        int dep[N];             // æ·±åº¦
        int fa[N][25];          // çˆ¶äº²stè¡¨
        int mxFa[N];            // ä¼˜åŒ– -> iæœ€å¤šæœ‰mxFa[i]å±‚ç¥–å…ˆ
        ll  minv[N];             // 1åˆ°içš„æœ€å°è¾¹æƒæ˜¯minv[i]
        
        // é¢„å¤„ç†fa[][]ï¼Œdfn[]ï¼Œminv[]
        inline void dfs ( int pos ) {
                int k;
                for ( k = 0; fa[pos][k]; k ++ ) fa[pos][k + 1] = fa[fa[pos][k]][k];
                mxFa[pos] = k;
                dfn[pos] = dfscnt ++;
                for ( int i = head[pos]; i; i = edge[i].nxt ) {
                        int to = edge[i].to;
                        if ( !dfn[to] ) 
                                dep[to] = dep[pos] + 1,
                                minv[to] = min ( minv[pos], edge[i].val ),
                                fa[to][0] = pos,
                                dfs ( to );
                }
        }

        // stæ±‚LCA
        inline int LCA ( int x, int y ) {
                if ( dep[x] < dep[y] ) swap ( x, y );
                for ( int i = mxFa[x]; i >= 0; i -- ) if ( dep[fa[x][i]] >= dep[y] ) x = fa[x][i];
                if ( x == y ) return x;
                for ( int i = mxFa[x]; i >= 0; i -- ) if ( fa[x][i] != fa[y][i] ) x = fa[x][i],
                                                                                  y = fa[y][i];
                return fa[x][0];
        }
        int stk[N], top; // å•è°ƒæ ˆ
        int lst[N];      // æŸ¥è¯¢çš„ä¸€å¥—å…³é”®ç‚¹
        inline void build () {
                sort ( lst + 1, lst + num + 1, [&]( int x, int y ) { return dfn[x] < dfn[y]; } ); // æŒ‰dfsåºæ’åº
                stk[top = 1] = lst[1]; // æ­¤æ—¶stk[0] = 0ï¼Œdep[0] = 0ï¼Œæ·±åº¦æœ€å°çš„å“¨å…µ
                for ( int i = 2; i <= num; i ++ ) {
                        int now = lst[i];
                        int lca = LCA ( now, stk[top] );
                        while ( 1 ) {
                                if ( dep[lca] >= dep[stk[top - 1]] ) { // lcaå·²åœ¨ä¸‹é¢ï¼Œåº”ä½œä¸ºå³é“¾å…ƒç´ äº†
                                        if ( lca != stk[top] ) {       // topè¦åˆ æ‰äº†
                                                add_vEdge ( lca, stk[top] );
                                                if ( lca != stk[top - 1] ) stk[top] = lca; // lcaåŠ å…¥
                                                else                       top --;         // lcaå·²æœ‰
                                        }
                                        break;
                                } else { // ä¸€ç›´å¼¹ç›´åˆ°lcaåœ¨ä¸‹é¢
                                        add_vEdge ( stk[top - 1], stk[top] );
                                        top --;
                                }
                        }
                        stk[ ++ top ] = now;
                }
                while ( --top ) add_vEdge ( stk[top], stk[top + 1] );
        }
} using namespace VirtualTree;

bool query[N];
inline ll dp ( int pos ) {
        ll sum = 0, res;
        for ( int i = vhead[pos]; i; i = vedge[i].nxt ) sum += dp ( vedge[i].to );
        if ( query[pos] ) res = minv[pos];
        else              res = min ( minv[pos], sum );
        // å®æ—¶æ¸…ç©º
        query[pos] = false;
        vhead[pos] = 0;
        return res;
}

int main () {
        minv[1] = 1e18;
        scanf("%d", &n);
        for ( ll i = 0, x, y, val; i < n - 1; i ++ ) 
                scanf("%lld%lld%lld", &x, &y, &val),
                add_Edge ( x, y, val ),
                add_Edge ( y, x, val );
        dfs ( 1 );
        scanf("%d", &q);
        while ( q -- ) {
                scanf("%d", &num);
                for ( int i = 1; i <= num; i ++ ) scanf("%d", &lst[i]), query[lst[i]] = true;
                build();
                printf("%lld\n", dp(stk[1]));
                vcnt = 0;
        }
} 

```
