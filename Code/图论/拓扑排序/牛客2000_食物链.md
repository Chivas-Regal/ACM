# 🔗
https://ac.nowcoder.com/acm/problem/20000

# 💡
dp思想太好用了，没想到可以用dp推链数  
拓扑包含入读和出度  
开始选择入队元素时要特判只有出度不为0的才能入  
并每个入队的链数dp设为1  
每次有一个新元素要进队就加上起点的链数dp  
最后统计所有出度为0的元素的dp和  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >  
  
```cpp
#pragma region
#pragma GCC optimize(3,"Ofast","inline")
#include <algorithm>
#include <iostream>
#include <cstring>
#include <string>
#include <vector>
#include <cstdio>
#include <stack>
#include <queue>
#include <cmath>
#include <map>
#include <set>
#define G 10.0
#define LNF 1e18
#define eps 1e-6
#define PI acos(-1.0)
#define ll long long
#define INF 0x7FFFFFFF
#define Regal exit(0)
#define Chivas int main()
#define pb(x) push_back(x)
#define SP system("pause")
#define Max(a,b) ((a)>(b)?(a):(b))
#define Min(a,b) ((a)<(b)?(a):(b))
#define IOS ios::sync_with_stdio(false)
#define mm(a, b) memset(a, b, sizeof(a))
#define each_cass(cass) for (cin>>cass; cass; cass--)
#define test(a) cout << "---------" << a << "---------" << '\n'
using namespace std;
#pragma endregion

//全局变量
#pragma region
const int maxn = 1e5 + 10;
//----------------前向星变量
struct Edge{
    int nxt, to;
}edge[maxn << 1];
int head[maxn];
int cnt = 0;
//------------------------   
int n, m;//生物个数、关系数
int in[maxn], out[maxn];//入度，出度
int dp[maxn];//dp[i]表示到i的食物链有多少条
#pragma endregion

//辅助函数
void Init(){
    for(int i = 0; i < maxn; i ++){
        head[i] = -1;
        in[i] = 0;
        out[i] = 0;
        dp[i] = 0;
    }
    cnt = 0;
}
void Add_Edge(int from, int to){
    edge[++cnt] = {head[from], to};
    head[from] = cnt;
}
void TopSort(){
    queue<int> que;
    for(int i = 1; i <= n; i ++){//初始化队列和首位置的食物链条数
        if(in[i] == 0 && out[i] != 0){//没出度的不算，就自己一个不是一条链
            que.push(i);
            dp[i] = 1;
        }
    }
    while(!que.empty()){
        int cur_start = que.front();
        que.pop();
        for(int i = head[cur_start]; ~i; i = edge[i].nxt){
            int cur_end = edge[i].to;
            in[cur_end]--;
            dp[cur_end] += dp[cur_start];//关键：链数传递
            if(!in[cur_end]){
                que.push(cur_end);
            }
        }
    }
}

//主函数
Chivas{
    IOS;
    Init();
    cin >> n >> m;
    while(m --){
        int x, y;
        cin >> x >> y;
        Add_Edge(x, y);
        in[y] ++;
        out[x] ++;
    }
    TopSort();
    int res = 0;
    for(int i = 1; i <= n; i++){
        if(out[i] == 0){
            res += dp[i];//统计最后的点的食物链条数总和
        }
    }
    cout << res << endl;
    Regal;
}

```
