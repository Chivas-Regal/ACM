# 🔗
<a href="https://www.luogu.com.cn/problem/P3674"><img src="https://i.loli.net/2021/09/12/LhMZuKQd7z5mC12.png"></a>

# 💡
一道莫队维护bitset的好题  
bitset是一个很妙的STL容器，可以实现很多优化  
是否有两个数的差为<img src="https://latex.codecogs.com/svg.image?x" title="x" />，只需要判断<img src="https://latex.codecogs.com/svg.image?bst1\And&space;(bst1&space;<<&space;x)" title="bst1\And (bst1 << x)" />是否存在1即可 
  
是否有两个数的和为<img src="https://latex.codecogs.com/svg.image?x" title="x" />  
可以推导一下  
<img src="https://latex.codecogs.com/svg.image?\begin{aligned}a-N&plus;b=x-N\\a-(N-b)=x-N\\a=(N-b)-(N-x)\end{aligned}" title="\begin{aligned}a-N+b=x-N\\a-(N-b)=x-N\\a=(N-b)-(N-x)\end{aligned}" />  
那么我们建立一个存放<img src="https://latex.codecogs.com/svg.image?N-x" title="N-x" />的bst2，然后查一下<img src="https://latex.codecogs.com/svg.image?bst1&space;\And&space;(bst2&space;>>&space;(N-x))" title="bst1 \And (bst2 >> (N-x))" />中是否存在1即可  
  
是否有两个数的积为<img src="https://latex.codecogs.com/svg.image?x" title="x" />  
直接暴力枚举因数然后查一下在不在就行了  
  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
#include <map>
#include <bitset>
#define ll long long

using namespace std;

const int N = 1e5 + 10;
int n, m, len;
int a[N];
struct Q {
        int id, l, r;
        int tgt, opt;
} q[N];
bitset<N> bst1, bst2;
int res[N], vis[N];

inline void add ( int x ) {
        if ( !(vis[x] ++) ) bst1[x] = bst2[N - x] = true;
}
inline void del ( int x ) {
        if ( !(-- vis[x]) ) bst1[x] = bst2[N - x] = false;
}


inline int get ( int x ) {
        return x / len;
}

int main () {
        ios::sync_with_stdio(false);
#ifndef ONLINE_JUDGE
        freopen("in.in", "r", stdin);
        freopen("out.out", "w", stdout);
#endif
        cin >> n >> m; len = sqrt ( n );
        for ( int i = 1; i <= n; i ++ ) cin >> a[i];
        for ( int i = 0; i < m; i ++ ) {
                int opt, l, r, x; cin >> opt >> l >> r >> x;
                q[i] = {i, l, r, x, opt};
        }
        sort ( q, q + m, [&](Q a, Q b){
                if ( get(a.l) != get(b.l) ) return get(a.l) < get(b.l);
                return a.r < b.r;
        });
        for ( int L = 1, R = 0, i = 0; i < m; i ++ ) {
                
                while ( L < q[i].l ) del ( a[ L ++ ] );
                while ( L > q[i].l ) add ( a[ -- L ] );
                while ( R > q[i].r ) del ( a[ R -- ] );
                while ( R < q[i].r ) add ( a[ ++ R ] );

                if ( q[i].opt == 1 ) {
                        res[q[i].id] = (bst1 & (bst1 << q[i].tgt)).any();
                } else if ( q[i].opt == 2 ) {
                        res[q[i].id] = (bst1 & (bst2 >> (N - q[i].tgt))).any();
                } else {
                        for ( int j = 1; j * j <= q[i].tgt; j ++ ) {
                                if ( q[i].tgt % j == 0 && bst1[j] && bst1[q[i].tgt / j] ) {
                                        res[q[i].id] = true;
                                        break;
                                }
                        }
                }
        }
        for ( int i = 0; i < m; i ++ ) {
                puts(res[i] ? "hana" : "bi");
        }
}
```
