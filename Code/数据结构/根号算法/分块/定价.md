# 🔗
https://www.luogu.com.cn/problem/P4109

# 💡
同样的长度，后面的0越多，则荒谬度越小  
所以我们可以设定一个固定的len值为十的正整数次方，观测数据量，这里用10000更合适  
每10000为区间的数的荒谬度一样，同时题目又让求最小的，于是我们可以用块的最左侧数代表整个区间  
  
写一个VAL函数维护荒谬度，其余就是分块跑一遍就行了  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>

using namespace std;

int len = 10000;

inline int get ( int id ) { return id / len; }

inline int VAL ( int num ) {
        while ( num % 10 == 0 ) num /= 10;
        return 2 * to_string(num).size() - (num % 10 == 5);
}

inline int Query ( int l, int r ) {
        int res = l, MinVal = VAL(l);
        if ( get(l) == get(r) ) {
                for ( int i = l; i <= r; i ++ ) if ( MinVal > VAL(i) ) MinVal = VAL(i), res = i;
        } else {
                int i = l, j = r;
                while ( get(i) == get(l) ) { if ( MinVal > VAL(i) ) MinVal = VAL(i), res = i; i ++; }
                for ( int k = get(i); k < get(j); k ++ ) if ( MinVal > VAL(k * len) ) MinVal = VAL(k * len), res = k * len;
                while ( get(j) == get(r) ) { if ( MinVal > VAL(j) ) MinVal = VAL(j), res = j; j --; }
        }
        return res;
}

int main () {

        int cass;
        for ( cin >> cass; cass; cass -- ) {
                int l, r; cin >> l >> r;
                cout << Query ( l, r ) << endl;
        }

}
```
