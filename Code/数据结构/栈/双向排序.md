# 🔗
<a href=""><img src="https://i.loli.net/2021/09/22/46SQYXihVCWzBJm.png"></a>

# 💡
首先在相同种类的操作重叠时  
除了最大长度的，别的都没有作用  
所以可以把操作种类变为一个个01来回跳的操作  
  
然后还可以进行下面的优化
<img src="https://i.loli.net/2021/09/22/weHq8EA5rtK7pbj.jpg"> 
可以通过栈来维护有效操作  
可以发现[l, r]不断缩进，那么有效操作确定之后可以进行赋值了  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <stack>

using namespace std;

const int N = 1e5 + 10;
#define x first
#define y second
#define pii pair<int, int>

int n, m;
vector<pair<int, int> > stk; // first = op, second = x
int res[N];

int main () {
#ifndef ONLINE_JUDGE
	freopen("in.in", "r", stdin);
	freopen("out.out", "w", stdout);
#endif
	stk.push_back({0, 100});
	cin >> n >> m;
	while ( m -- ) {
		int p, q; cin >> p >> q;
		if ( p == 0 ) { // 前缀
			while ( stk.size() && stk.back().x == 0 ) // 同种操作
				q = max ( q, stk.back().y ),
				stk.pop_back();
			while ( stk.size() >= 2 && stk[stk.size() - 2].y <= q ) // 若这次操作区间覆盖了上次同类操作的区间，可以完整删掉前两次操作
				stk.pop_back(),
				stk.pop_back();
		} else if ( stk.size() ) { // 后缀
			while ( stk.size() && stk.back().x == 1 ) 
				q = min ( q, stk.back().y ),
				stk.pop_back();
			while ( stk.size() >= 2 && stk[stk.size() - 2].y >= q ) 
				stk.pop_back(),
				stk.pop_back();
		}
		stk.push_back({p, q});
	}
	int k = n, l = 1, r = n;
	for ( int i = 0; i < stk.size(); i ++ ) { // 一个个缩进区间并赋值
		if ( stk[i].x == 0 ) {
			while ( r > stk[i].y && l <= r ) res[ r -- ] = k --;
		} else {
			while ( l < stk[i].y && l <= r ) res[ l ++ ] = k --;
		}
		if ( l > r ) break;
	}
	if ( stk.size() % 2 ) // 漏了一个
		while ( l <= r ) res[ l ++ ] = k --;
	else 
		while ( l <= r ) res[ r -- ] = k --;
	for ( int i = 1; i <= n; i ++ ) cout << res[i] << " ";
}
```
