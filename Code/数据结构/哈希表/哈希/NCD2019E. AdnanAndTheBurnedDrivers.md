# 🔗
<a href="https://codeforces.com/gym/102163/problem/E"><img src="https://s2.loli.net/2022/01/06/17kR6dVvMn5plqj.png"></a>

# 💡
题目暗示过**回文串是正着读和反着读都一样的串**  
而这里也有改数一样的单点修改和区间查询  
那么我们可以用字符串  <img src="https://latex.codecogs.com/svg.image?\inline&space;Hash" title="\inline Hash" /> + 线段树  
  
字符串  <img src="https://latex.codecogs.com/svg.image?\inline&space;Hash" title="\inline Hash" /> 为一个正读  <img src="https://latex.codecogs.com/svg.image?\inline&space;Hash:s_1" title="\inline Hash" /> 和一个反渎  <img src="https://latex.codecogs.com/svg.image?\inline&space;Hash:s_2" title="\inline Hash:s_2" />，将这两个数组作为线段树数组     
  
我们单点修改的时候也就是重启所有连接到这个点的段值，这个处理一个  <img src="https://latex.codecogs.com/svg.image?\inline&space;pw" title="\inline pw" /> 数组作为  <img src="https://latex.codecogs.com/svg.image?\inline&space;base" title="\inline base" /> 的幂  
一个修改中  

```cpp
s1[rt] = s1[rt << 1] * pw[r - mid] + s1[rt << 1 | 1] // 正读左边乘base的次数幂
s2[rt] = s2[rt << 1] + s2[rt << 1 | 1] * pw[mid - l + 1] // 反读右边乘base的次数幂
``` 
  
一个查询中，就和线段树一样要对于查询的段左子树查询右子树查询  
和上面注释同理，这里也要正读反读各自乘幂  

```cpp
// 当然如果整个区间在左一半直接递归左半边即可，否则右半边
which ? ( Query ( l, mid, rt << 1, ql, mid, which ) + Query ( mid + 1, r, rt << 1 | 1, mid + 1, qr, which ) * pw[mid - ql + 1] ) % mod
      : ( Query ( l, mid, rt << 1, ql, mid, which ) * pw[qr - mid] + Query ( mid + 1, r, rt << 1 | 1, mid + 1, qr, which )) % mod; // which：0——正读，1——反读
```     
  
这样操作下来，我们每次查询的时候如果这个段长是奇数，就差  <img src="https://latex.codecogs.com/svg.image?\inline&space;[l,mid]" title="\inline [l,mid]" /> 的正读和  <img src="https://latex.codecogs.com/svg.image?\inline&space;[mid,r]" title="\inline [mid,r]" /> 的反读  
否则差  <img src="https://latex.codecogs.com/svg.image?\inline&space;[l,mid-1]" title="\inline [l,mid-1]" /> 的正和  <img src="https://latex.codecogs.com/svg.image?\inline&space;[mid+1,r]" title="\inline [mid+1,r]" /> 的反  
比较这两个，如果一样的话就是回文  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
const ll mod = 1e9 + 3;
const ll base = 131;
const ll N = 1e5 + 10;

ll n, m;
ll s1[N << 2], s2[N << 2];
char s[N];
ll pw[N];

inline void get_Pw () {
        pw[0] = 1;
        for ( ll i = 1; i < N; i ++ ) pw[i] = pw[i - 1] * base % mod;
}

inline void Update ( ll l, ll r, ll rt, ll id, ll c ) {
        if ( l == r ) {
                s1[rt] = s2[rt] = c;
                return;
        }

        ll mid = (l + r) >> 1;
        if ( id <= mid ) Update(l, mid, rt << 1, id, c);
        else             Update(mid + 1, r, rt << 1 | 1, id, c);
        s1[rt] = (s1[rt << 1] * pw[r - mid] + s1[rt << 1 | 1]) % mod;
        s2[rt] = (s2[rt << 1] + s2[rt << 1 | 1] * pw[mid - l + 1]) % mod;
}

inline ll Query ( ll l, ll r, ll rt, ll ql, ll qr, ll which ) { // 0:正，1:反
         if ( l == ql && r == qr ) return which? s2[rt] : s1[rt];
         ll mid = (l + r) >> 1;
         if ( qr <= mid ) return Query ( l, mid, rt << 1, ql, qr, which );
         else if ( ql > mid ) return Query ( mid + 1, r, rt << 1 | 1, ql, qr, which );
         else return which? ( Query ( l, mid, rt << 1, ql, mid, which ) + Query ( mid + 1, r, rt << 1 | 1, mid + 1, qr, which ) * pw[mid - ql + 1] ) % mod
                          : ( Query ( l, mid, rt << 1, ql, mid, which ) * pw[qr - mid] + Query ( mid + 1, r, rt << 1 | 1, mid + 1, qr, which )) % mod;
}

inline void Solve () {
        scanf("%lld%lld", &n, &m);
        getchar();
        scanf("%s", s + 1);
        for ( ll i = 1; i <= n; i ++ ) Update(1, n, 1, i, s[i]);
        while ( m -- ) {
                ll op; scanf("%lld", &op);
                if ( op == 1 ) {
                        ll id; scanf("%lld", &id); 
                        getchar();
                        char c; scanf("%c", &c);
                        Update ( 1, n, 1, id, c );

                        s[id] = c;
                } else {
                        ll l, r; scanf("%lld%lld", &l, &r);
                        ll mid = (l + r) >> 1;
                        if ( l == r ) {
                                puts("Adnan Wins");
                        } else if ( (r - l + 1) & 1 ) {
                                puts(Query(1, n, 1, l, mid - 1, 0) == Query(1, n, 1, mid + 1, r, 1) ? "Adnan Wins" : "ARCNCD!");
                        } else {
                                puts(Query(1, n, 1, l, mid, 0) == Query(1, n, 1, mid + 1, r, 1) ? "Adnan Wins" : "ARCNCD!");
                        }
                }
        }
}

int main () {
        get_Pw();
        ll cass; scanf("%lld", &cass); while ( cass -- ) {
                Solve ();
        }
}
```
