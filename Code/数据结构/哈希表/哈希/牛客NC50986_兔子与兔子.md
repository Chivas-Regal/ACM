# 🔗
https://ac.nowcoder.com/acm/contest/1008/B

# 💡
将字符串定义为一种进制  
保证不同的字符串进制一定不同  
  
建立一个hash表映射i位置前的字符串进制  
  
在求区间字符串时只需要求区间进制即可  
进制相同就字符串相同，否则不同  

# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >  
  
```cpp
#pragma region
//#pragma GCC optimize(3,"Ofast","inline")
#include <algorithm>
#include <iostream>
#include <cstring>
#include <string>
#include <vector>
#include <cstdio>
#include <stack>
#include <queue>
#include <cmath>
#include <map>
#include <set>
#define G 10.0
#define LNF 1e18
#define eps 1e-6
#define PI acos(-1.0)
#define ll long long
#define INF 0x7FFFFFFF
#define Regal exit(0)
#define Chivas int main()
#define pb(x) push_back(x)
#define SP system("pause")
#define ull unsigned long long
#define Max(a,b) ((a)>(b)?(a):(b))
#define Min(a,b) ((a)<(b)?(a):(b))
#define IOS ios::sync_with_stdio(false)
#define mm(a, b) memset(a, b, sizeof(a))
#define each_cass(cass) for (cin>>cass; cass; cass--)
#define test(a) cout << "---------" << a << "---------" << '\n'
 
using namespace std;
#pragma endregion

//全局变量
#pragma region
const int maxn = 2e6 + 10;
const int base = 131;
char s[maxn];
int Q;
ull _hash[maxn], sys[maxn];//_hash[i]表示i以前的字符串进制，sys[i]表示base^i
#pragma endregion

//主体-------------------------------------------------------------------
inline void Init_system(){//将字符串每一位化为一个进制数，并初始化这个进制表
    int len = strlen(s + 1);
    _hash[0] = 0, sys[0] = 1;
    for(int i = 1; i <= len; i ++){
        _hash[i] = _hash[i - 1] * base + s[i] - 'a' + 1;
        sys[i] = sys[i - 1] * base;
    }
}

inline ull Get_lr(int l, int r){//求l~r的区间进制
    return _hash[r] - _hash[l - 1] * sys[r - l + 1];//类似于区间和，这里求区间进制
}

Chivas{
    scanf("%s", s + 1);
    Init_system();
    cin >> Q;
    while(Q --){
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        cout << (Get_lr(l1, r1) == Get_lr(l2, r2) ? "Yes" : "No") << endl;
    }
    Regal;
}
```
