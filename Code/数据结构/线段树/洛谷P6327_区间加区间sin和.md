# 🔗
<a href="https://www.luogu.com.cn/problem/P6327"><img src="https://img-blog.csdnimg.cn/d5f8f4e7a8124d3188ca5ef74cc95240.png"></a>

# 💡

首先看修改，对 <img src="https://latex.codecogs.com/svg.image?\inline&space;a" title="\inline a" /> 加 <img src="https://latex.codecogs.com/svg.image?\inline&space;x" title="\inline a" />  
<img src="https://latex.codecogs.com/svg.image?\inline&space;\sin(a+x)" title="\inline a" /> 可以想到和差化积 <img src="https://latex.codecogs.com/svg.image?\inline&space;=\sin(a)\cos(x)+\sin(x)\cos(a)" title="\inline a" />  
我们可以看到每次会用到两个值 <img src="https://latex.codecogs.com/svg.image?\inline&space;\cos" title="\inline a" /> 和 <img src="https://latex.codecogs.com/svg.image?\inline&space;\sin" title="\inline a" /> ，那么我们线段树维护这两个就行了  
可以发现修改也是可以在原有基础上进行 <img src="https://latex.codecogs.com/svg.image?\inline&space;\cos(x)" title="\inline a" /> 和 <img src="https://latex.codecogs.com/svg.image?\inline&space;\sin(x)" title="\inline a" /> 的乘法分配律的  
所以我们可以正常 <img src="https://latex.codecogs.com/svg.image?\inline&space;lazy" title="\inline lazy" /> 维护加的 <img src="https://latex.codecogs.com/svg.image?\inline&space;\sum&space;x" title="\inline a" />    


# <img src="https://img-blog.csdnimg.cn/20210713144601841.png" >
```cpp
# include <iostream>
# include <algorithm>
# include <cstring>
# include <vector>
# include <map>
# include <cmath>


# define ll long long

using namespace std;

const int N = 2e5 + 10;
int a[N], n, m;

struct Sgtr {
        double sine, cosi;
        ll lazy;
}sgtr[N << 2];

inline void Calc ( double &sumsin, double &sumcos, ll x ) {
        double tmp_sumsin = sumsin;
        double tmp_sumcos = sumcos;
        double sinx       = sin(x);
        double cosx       = cos(x);
        sumsin = tmp_sumsin * cosx + tmp_sumcos * sinx;
        sumcos = tmp_sumcos * cosx - tmp_sumsin * sinx;
}

inline void PushUp ( int rt ) {
        sgtr[rt].sine = sgtr[rt << 1].sine + sgtr[rt << 1 | 1].sine;
        sgtr[rt].cosi = sgtr[rt << 1].cosi + sgtr[rt << 1 | 1].cosi;
}

inline void PushDown ( int l, int r, int rt ) {
        if (!sgtr[rt].lazy) return;

        sgtr[rt << 1].lazy     += sgtr[rt].lazy;
        sgtr[rt << 1 | 1].lazy += sgtr[rt].lazy;

        Calc (sgtr[rt << 1].sine,     sgtr[rt << 1].cosi,     sgtr[rt].lazy);
        Calc (sgtr[rt << 1 | 1].sine, sgtr[rt << 1 | 1].cosi, sgtr[rt].lazy);

        sgtr[rt].lazy = 0;
}

inline void Build ( int l = 1, int r = n, int rt = 1 ) {
        sgtr[rt].lazy = 0;
        if (l == r) {
                sgtr[rt].cosi = cos(a[l]);
                sgtr[rt].sine = sin(a[l]);
                return;
        }

        int mid = (l + r) >> 1;
        Build (l, mid, rt << 1);
        Build (mid + 1, r, rt << 1 | 1);
        PushUp (rt);
}

inline void Update ( int a, int b, ll c, int l = 1, int r = n, int rt = 1 ) {
        if (a <= l && r <= b) {
                sgtr[rt].lazy += c;
                Calc (sgtr[rt].sine, sgtr[rt].cosi, c);
                return;
        }
        if (a > r || b < l) return;

        int mid = (l + r) >> 1;
        PushDown (l, r, rt);
        Update (a, b, c, l, mid, rt << 1);
        Update (a, b, c, mid + 1, r, rt << 1 | 1);
        PushUp (rt);
}

inline double Query ( int a, int b, int l = 1, int r = n, int rt = 1 ) {
        if (a <= l && r <= b) return sgtr[rt].sine;
        if (a > r || b < l)   return 0;
        PushDown (l, r, rt);
        int mid = (l + r) >> 1;
        return Query (a, b, l, mid, rt << 1) + Query (a, b, mid + 1, r, rt << 1 | 1);
}

int main () {
        scanf("%d", &n);
        for ( int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
        scanf("%d", &m);

        Build();
        while ( m -- ) {
                int op; scanf("%d", &op);
                if ( op == 1 ) {
                        int l, r, v; scanf("%d%d%d", &l, &r, &v);
                        Update (l, r, v);
                } else {
                        int l, r;    scanf("%d%d", &l, &r);
                        printf("%.1f\n", Query(l, r));
                }
        }
}
```
